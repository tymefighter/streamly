<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Stream.Combinators</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.Combinators.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-0.7.1: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Harendra Kumar</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.Combinators</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:maxThreads">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxBuffer">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxYields">maxYields</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:rate">rate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Streamly-Internal-Data-SVar.html#t:Rate" title="Streamly.Internal.Data.SVar">Rate</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:avgRate">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:minRate">minRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxRate">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:constRate">constRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:inspectMode">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:printState">printState</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m ()</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:maxThreads" class="def">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxThreads" class="link">Source</a> <a href="#v:maxThreads" class="selflink">#</a></p><div class="doc"><p>Specify the maximum number of threads that can be spawned concurrently for
 any concurrent combinator in a stream.
 A value of 0 resets the thread limit to default, a negative value means
 there is no limit. The default value is 1500. <code><a href="Streamly-Internal-Data-Stream-Combinators.html#v:maxThreads" title="Streamly.Internal.Data.Stream.Combinators">maxThreads</a></code> does not affect
 <code>ParallelT</code> streams as they can use unbounded number of threads.</p><p>When the actions in a stream are IO bound, having blocking IO calls, this
 option can be used to control the maximum number of in-flight IO requests.
 When the actions are CPU bound this option can be used to
 control the amount of CPU used by the stream.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxBuffer" class="def">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxBuffer" class="link">Source</a> <a href="#v:maxBuffer" class="selflink">#</a></p><div class="doc"><p>Specify the maximum size of the buffer for storing the results from
 concurrent computations. If the buffer becomes full we stop spawning more
 concurrent tasks until there is space in the buffer.
 A value of 0 resets the buffer size to default, a negative value means
 there is no limit. The default value is 1500.</p><p>CAUTION! using an unbounded <code><a href="Streamly-Internal-Data-Stream-Combinators.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.Combinators">maxBuffer</a></code> value (i.e. a negative value)
 coupled with an unbounded <code><a href="Streamly-Internal-Data-Stream-Combinators.html#v:maxThreads" title="Streamly.Internal.Data.Stream.Combinators">maxThreads</a></code> value is a recipe for disaster in
 presence of infinite streams, or very large streams.  Especially, it must
 not be used when <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is used in <code>ZipAsyncM</code> streams as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> in
 applicative zip streams generates an infinite stream causing unbounded
 concurrent generation with no limit on the buffer or threads.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxYields" class="def">maxYields</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxYields" class="link">Source</a> <a href="#v:maxYields" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:rate" class="def">rate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Streamly-Internal-Data-SVar.html#t:Rate" title="Streamly.Internal.Data.SVar">Rate</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#rate" class="link">Source</a> <a href="#v:rate" class="selflink">#</a></p><div class="doc"><p>Specify the pull rate of a stream.
 A <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> value resets the rate to default which is unlimited.  When the
 rate is specified, concurrent production may be ramped up or down
 automatically to achieve the specified yield rate. The specific behavior for
 different styles of <code><a href="Streamly-Internal-Data-SVar.html#t:Rate" title="Streamly.Internal.Data.SVar">Rate</a></code> specifications is documented under <code><a href="Streamly-Internal-Data-SVar.html#t:Rate" title="Streamly.Internal.Data.SVar">Rate</a></code>.  The
 effective maximum production rate achieved by a stream is governed by:</p><ul><li>The <code><a href="Streamly-Internal-Data-Stream-Combinators.html#v:maxThreads" title="Streamly.Internal.Data.Stream.Combinators">maxThreads</a></code> limit</li><li>The <code><a href="Streamly-Internal-Data-Stream-Combinators.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.Combinators">maxBuffer</a></code> limit</li><li>The maximum rate that the stream producer can achieve</li><li>The maximum rate that the stream consumer can achieve</li></ul><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:avgRate" class="def">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#avgRate" class="link">Source</a> <a href="#v:avgRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r (2*r) maxBound)</code></p><p>Specifies the average production rate of a stream in number of yields
 per second (i.e.  <code>Hertz</code>).  Concurrent production is ramped up or down
 automatically to achieve the specified average yield rate. The rate can
 go down to half of the specified rate on the lower side and double of
 the specified rate on the higher side.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:minRate" class="def">minRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#minRate" class="link">Source</a> <a href="#v:minRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r (2*r) maxBound)</code></p><p>Specifies the minimum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go below the
 specified rate, even though it may possibly go above it at times, the
 upper limit is double of the specified rate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxRate" class="def">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxRate" class="link">Source</a> <a href="#v:maxRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r r maxBound)</code></p><p>Specifies the maximum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go above the
 specified rate, even though it may possibly go below it at times, the
 lower limit is half of the specified rate. This can be useful in
 applications where certain resource usage must not be allowed to go
 beyond certain limits.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:constRate" class="def">constRate</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#constRate" class="link">Source</a> <a href="#v:constRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r r 0)</code></p><p>Specifies a constant yield rate. If for some reason the actual rate
 goes above or below the specified rate we do not try to recover it by
 increasing or decreasing the rate in future.  This can be useful in
 applications like graphics frame refresh where we need to maintain a
 constant refresh rate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:inspectMode" class="def">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#inspectMode" class="link">Source</a> <a href="#v:inspectMode" class="selflink">#</a></p><div class="doc"><p>Print debug information about an SVar when the stream ends</p></div></div><div class="top"><p class="src"><a id="v:printState" class="def">printState</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-SVar.html#t:State" title="Streamly.Internal.Data.SVar">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.Combinators.html#printState" class="link">Source</a> <a href="#v:printState" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>