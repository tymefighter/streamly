<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Network.Socket</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Network.Socket.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-v0.7.0: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2018 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Network.Socket</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Socket Specification</a></li><li><a href="#g:2">Accept Connections</a></li><li><a href="#g:3">Read</a></li><li><a href="#g:4">Write</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A socket is a handle to a protocol endpoint.</p><p>This module provides APIs to read and write streams and arrays to and from
 network sockets. Sockets may be connected or unconnected. Connected sockets
 can only send or recv data to/from the connected endpoint, therefore, APIs
 for connected sockets do not need to explicitly specify the remote endpoint.
 APIs for unconnected sockets need to explicitly specify the remote endpoint.</p><h1>Programmer Notes</h1><p>Read IO requests to connected stream sockets are performed in chunks of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.  Unless specified
 otherwise in the API, writes are collected into chunks of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code> before they are
 written to the socket. APIs are provided to control the chunking behavior.</p><pre>import qualified Streamly.Network.Socket as SK</pre><p>For additional, experimental APIs take a look at
 <a href="Streamly-Internal-Network-Socket.html">Streamly.Internal.Network.Socket</a> module.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:SockSpec">SockSpec</a> = <a href="#v:SockSpec">SockSpec</a> {<ul class="subs"><li><a href="#v:sockFamily">sockFamily</a> :: !Family</li><li><a href="#v:sockType">sockType</a> :: !SocketType</li><li><a href="#v:sockProto">sockProto</a> :: !ProtocolNumber</li><li><a href="#v:sockOpts">sockOpts</a> :: ![(SocketOption, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)]</li></ul>}</li><li class="src short"><a href="#v:accept">accept</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="Streamly-Network-Socket.html#t:SockSpec" title="Streamly.Network.Socket">SockSpec</a>, SockAddr) Socket</li><li class="src short"><a href="#v:read">read</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:readWithBufferOf">readWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:readChunks">readChunks</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:readChunksWithBufferOf">readChunksWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:write">write</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:writeWithBufferOf">writeWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:writeChunks">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Socket Specification</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SockSpec" class="def">SockSpec</a> <a href="src/Streamly.Internal.Network.Socket.html#SockSpec" class="link">Source</a> <a href="#t:SockSpec" class="selflink">#</a></p><div class="doc"><p>Specify the socket protocol details.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SockSpec" class="def">SockSpec</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:sockFamily" class="def">sockFamily</a> :: !Family</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockType" class="def">sockType</a> :: !SocketType</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockProto" class="def">sockProto</a> :: !ProtocolNumber</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockOpts" class="def">sockOpts</a> :: ![(SocketOption, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)]</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><a href="#g:2" id="g:2"><h1>Accept Connections</h1></a><div class="top"><p class="src"><a id="v:accept" class="def">accept</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="Streamly-Network-Socket.html#t:SockSpec" title="Streamly.Network.Socket">SockSpec</a>, SockAddr) Socket <a href="src/Streamly.Internal.Network.Socket.html#accept" class="link">Source</a> <a href="#v:accept" class="selflink">#</a></p><div class="doc"><p>Unfold a three tuple <code>(listenQLen, spec, addr)</code> into a stream of connected
 protocol sockets corresponding to incoming connections. <code>listenQLen</code> is the
 maximum number of pending connections in the backlog. <code>spec</code> is the socket
 protocol and options specification and <code>addr</code> is the protocol address where
 the server listens for incoming connections.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Read</h1></a><div class="top"><p class="src"><a id="v:read" class="def">read</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Network.Socket.html#read" class="link">Source</a> <a href="#v:read" class="selflink">#</a></p><div class="doc"><p>Unfolds a <code>Socket</code> into a byte stream.  IO requests to the socket are
 performed in sizes of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readWithBufferOf" class="def">readWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Network.Socket.html#readWithBufferOf" class="link">Source</a> <a href="#v:readWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Unfolds the tuple <code>(bufsize, socket)</code> into a byte stream, read requests
 to the socket are performed using buffers of <code>bufsize</code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readChunks" class="def">readChunks</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.Network.Socket.html#readChunks" class="link">Source</a> <a href="#v:readChunks" class="selflink">#</a></p><div class="doc"><p>Unfolds a socket into a stream of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></code> arrays. Requests to the socket
 are performed using a buffer of size
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>. The
 size of arrays in the resulting stream are therefore less than or equal to
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readChunksWithBufferOf" class="def">readChunksWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.Network.Socket.html#readChunksWithBufferOf" class="link">Source</a> <a href="#v:readChunksWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Unfold the tuple <code>(bufsize, socket)</code> into a stream of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></code> arrays.
 Read requests to the socket are performed using a buffer of size <code>bufsize</code>.
 The size of an array in the resulting stream is always less than or equal to
 <code>bufsize</code>.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:4" id="g:4"><h1>Write</h1></a><div class="top"><p class="src"><a id="v:write" class="def">write</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.Network.Socket.html#write" class="link">Source</a> <a href="#v:write" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a socket. Accumulates the input in chunks of
 up to <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code> bytes before writing.</p><pre>write = <code><a href="Streamly-Network-Socket.html#v:writeWithBufferOf" title="Streamly.Network.Socket">writeWithBufferOf</a></code> <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeWithBufferOf" class="def">writeWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.Network.Socket.html#writeWithBufferOf" class="link">Source</a> <a href="#v:writeWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a socket. Accumulates the input in chunks of
 specified number of bytes before writing.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeChunks" class="def">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) () <a href="src/Streamly.Internal.Network.Socket.html#writeChunks" class="link">Source</a> <a href="#v:writeChunks" class="selflink">#</a></p><div class="doc"><p>Write a stream of arrays to a socket.  Each array in the stream is written
 to the socket as a separate IO request.</p><p><em>Since: 0.7.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>