<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Unfold</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Unfold.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-v0.7.0: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Unfold</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Unfold Type</a></li><li><a href="#g:2">Operations on Input</a></li><li><a href="#g:3">Operations on Output</a></li><li><a href="#g:4">Unfolds</a></li><li><a href="#g:5">Transformations</a></li><li><a href="#g:6">Filtering</a></li><li><a href="#g:7">Nesting</a></li><li><a href="#g:8">Exceptions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Streams forcing a closed control flow loop can be categorized under
 two types, unfolds and folds, both of these are duals of each other.</p><p>Unfold streams are really generators of a sequence of elements, we can also
 call them pull style streams. These are lazy producers of streams. On each
 evaluation the producer generates the next element.  A consumer can
 therefore pull elements from the stream whenever it wants to.  A stream
 consumer can multiplex pull streams by pulling elements from the chosen
 streams, therefore, pull streams allow merging or multiplexing.  On the
 other hand, with this representation we cannot split or demultiplex a
 stream.  So really these are stream sources that can be generated from a
 seed and can be merged or zipped into a single stream.</p><p>The dual of Unfolds are Folds. Folds can also be called as push style
 streams or reducers. These are strict consumers of streams. We keep pushing
 elements to a fold and we can extract the result at any point. A driver can
 choose which fold to push to and can also push the same element to multiple
 folds. Therefore, folds allow splitting or demultiplexing a stream. On the
 other hand, we cannot merge streams using this representation. So really
 these are stream consumers that reduce the stream to a single value, these
 consumers can be composed such that a stream can be split over multiple
 consumers.</p><p>Performance:</p><p>Composing a tree or graph of computations with unfolds can be much more
 efficient compared to composing with the Monad instance.  The reason is that
 unfolds allow the compiler to statically know the state and optimize it
 using stream fusion whereas it is not possible with the monad bind because
 the state is determined dynamically.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:lmap">lmap</a> :: (a -&gt; c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:lmapM">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:supply">supply</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b</li><li class="src short"><a href="#v:supplyFirst">supplyFirst</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c -&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m b c</li><li class="src short"><a href="#v:supplySecond">supplySecond</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c -&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:discardFirst">discardFirst</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, a) b</li><li class="src short"><a href="#v:discardSecond">discardSecond</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) b</li><li class="src short"><a href="#v:swap">swap</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, a) b</li><li class="src short"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; a -&gt; m c</li><li class="src short"><a href="#v:fromStream">fromStream</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b</li><li class="src short"><a href="#v:fromStream1">fromStream1</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:fromStream2">fromStream2</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; t m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c</li><li class="src short"><a href="#v:nilM">nilM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:consM">consM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:effect">effect</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b</li><li class="src short"><a href="#v:singleton">singleton</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:identity">identity</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a</li><li class="src short"><a href="#v:const">const</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:replicateM">replicateM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a</li><li class="src short"><a href="#v:fromList">fromList</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m [a] a</li><li class="src short"><a href="#v:fromListM">fromListM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m [m a] a</li><li class="src short"><a href="#v:enumerateFromStepIntegral">enumerateFromStepIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, a) a</li><li class="src short"><a href="#v:enumerateFromToIntegral">enumerateFromToIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a</li><li class="src short"><a href="#v:enumerateFromIntegral">enumerateFromIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a</li><li class="src short"><a href="#v:map">map</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:mapM">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:mapMWithInput">mapMWithInput</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:takeWhileM">takeWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:take">take</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:filter">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:filterM">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:concat">concat</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m b c -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m (<a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m () c)) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c</li><li class="src short"><a href="#v:outerProduct">outerProduct</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c d -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) (b, d)</li><li class="src short"><a href="#v:gbracket">gbracket</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; (<span class="keyword">forall</span> s. m s -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e s)) -&gt; (c -&gt; m d) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, e) b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:before">before</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:after">after</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:onException">onException</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:finally">finally</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:bracket">bracket</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; (c -&gt; m d) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li><li class="src short"><a href="#v:handle">handle</a> :: (MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m e b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Unfold Type</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Unfold" class="def">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.Types.html#Unfold" class="link">Source</a> <a href="#t:Unfold" class="selflink">#</a></p><div class="doc"><p>An <code>Unfold m a b</code> is a generator of a stream of values of type <code>b</code> from a
 seed of type <code>a</code> in <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> <code>m</code>.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Operations on Input</h1></a><div class="top"><p class="src"><a id="v:lmap" class="def">lmap</a> :: (a -&gt; c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#lmap" class="link">Source</a> <a href="#v:lmap" class="selflink">#</a></p><div class="doc"><p>Map a function on the input argument of the <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:lmapM" class="def">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#lmapM" class="link">Source</a> <a href="#v:lmapM" class="selflink">#</a></p><div class="doc"><p>Map an action on the input argument of the <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:supply" class="def">supply</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b <a href="src/Streamly.Internal.Data.Unfold.html#supply" class="link">Source</a> <a href="#v:supply" class="selflink">#</a></p><div class="doc"><p>Supply the seed to an unfold closing the input end of the unfold.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:supplyFirst" class="def">supplyFirst</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c -&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m b c <a href="src/Streamly.Internal.Data.Unfold.html#supplyFirst" class="link">Source</a> <a href="#v:supplyFirst" class="selflink">#</a></p><div class="doc"><p>Supply the first component of the tuple to an unfold that accepts a tuple
 as a seed resulting in a fold that accepts the second component of the tuple
 as a seed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:supplySecond" class="def">supplySecond</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c -&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#supplySecond" class="link">Source</a> <a href="#v:supplySecond" class="selflink">#</a></p><div class="doc"><p>Supply the second component of the tuple to an unfold that accepts a tuple
 as a seed resulting in a fold that accepts the first component of the tuple
 as a seed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:discardFirst" class="def">discardFirst</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, a) b <a href="src/Streamly.Internal.Data.Unfold.html#discardFirst" class="link">Source</a> <a href="#v:discardFirst" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> into an unfold accepting a tuple as an argument,
 using the argument of the original fold as the second element of tuple and
 discarding the first element of the tuple.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:discardSecond" class="def">discardSecond</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) b <a href="src/Streamly.Internal.Data.Unfold.html#discardSecond" class="link">Source</a> <a href="#v:discardSecond" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> into an unfold accepting a tuple as an argument,
 using the argument of the original fold as the first element of tuple and
 discarding the second element of the tuple.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:swap" class="def">swap</a> :: <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, a) b <a href="src/Streamly.Internal.Data.Unfold.html#swap" class="link">Source</a> <a href="#v:swap" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> that accepts a tuple as an argument into an unfold
 that accepts a tuple with elements swapped.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Operations on Output</h1></a><div class="top"><p class="src"><a id="v:fold" class="def">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; a -&gt; m c <a href="src/Streamly.Internal.Data.Unfold.html#fold" class="link">Source</a> <a href="#v:fold" class="selflink">#</a></p><div class="doc"><p>Compose an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> and a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. Given an <code>Unfold m a b</code> and a
 <code>Fold m b c</code>, returns a monadic action <code>a -&gt; m c</code> representing the
 application of the fold on the unfolded stream.</p><p><em>Internal</em></p></div></div><a href="#g:4" id="g:4"><h1>Unfolds</h1></a><div class="top"><p class="src"><a id="v:fromStream" class="def">fromStream</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b <a href="src/Streamly.Internal.Data.Unfold.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><div class="doc"><p>Convert a stream into an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>. Note that a stream converted to an
 <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> may not be as efficient as an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> in some situations.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromStream1" class="def">fromStream1</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#fromStream1" class="link">Source</a> <a href="#v:fromStream1" class="selflink">#</a></p><div class="doc"><p>Convert a single argument stream generator function into an
 <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>. Note that a stream converted to an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> may not be as
 efficient as an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> in some situations.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromStream2" class="def">fromStream2</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; t m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, b) c <a href="src/Streamly.Internal.Data.Unfold.html#fromStream2" class="link">Source</a> <a href="#v:fromStream2" class="selflink">#</a></p><div class="doc"><p>Convert a two argument stream generator function into an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>. Note
 that a stream converted to an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> may not be as efficient as an
 <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code> in some situations.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:nilM" class="def">nilM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#nilM" class="link">Source</a> <a href="#v:nilM" class="selflink">#</a></p><div class="doc"><p>Lift a monadic function into an unfold generating a nil stream with a side
 effect.</p></div></div><div class="top"><p class="src"><a id="v:consM" class="def">consM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><div class="doc"><p>Prepend a monadic single element generator function to an <code><a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:effect" class="def">effect</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b <a href="src/Streamly.Internal.Data.Unfold.html#effect" class="link">Source</a> <a href="#v:effect" class="selflink">#</a></p><div class="doc"><p>Lift a monadic effect into an unfold generating a singleton stream.</p></div></div><div class="top"><p class="src"><a id="v:singleton" class="def">singleton</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#singleton" class="link">Source</a> <a href="#v:singleton" class="selflink">#</a></p><div class="doc"><p>Lift a monadic function into an unfold generating a singleton stream.</p></div></div><div class="top"><p class="src"><a id="v:identity" class="def">identity</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a <a href="src/Streamly.Internal.Data.Unfold.html#identity" class="link">Source</a> <a href="#v:identity" class="selflink">#</a></p><div class="doc"><p>Identity unfold. Generates a singleton stream with the seed as the only
 element in the stream.</p><pre>identity = singleton return</pre></div></div><div class="top"><p class="src"><a id="v:const" class="def">const</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#const" class="link">Source</a> <a href="#v:const" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:replicateM" class="def">replicateM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a <a href="src/Streamly.Internal.Data.Unfold.html#replicateM" class="link">Source</a> <a href="#v:replicateM" class="selflink">#</a></p><div class="doc"><p>Generates a stream replicating the seed <code>n</code> times.</p></div></div><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m [a] a <a href="src/Streamly.Internal.Data.Unfold.html#fromList" class="link">Source</a> <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><p>Convert a list of pure values to a <code><a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a></code></p></div></div><div class="top"><p class="src"><a id="v:fromListM" class="def">fromListM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m [m a] a <a href="src/Streamly.Internal.Data.Unfold.html#fromListM" class="link">Source</a> <a href="#v:fromListM" class="selflink">#</a></p><div class="doc"><p>Convert a list of monadic values to a <code><a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a></code></p></div></div><div class="top"><p class="src"><a id="v:enumerateFromStepIntegral" class="def">enumerateFromStepIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, a) a <a href="src/Streamly.Internal.Data.Unfold.html#enumerateFromStepIntegral" class="link">Source</a> <a href="#v:enumerateFromStepIntegral" class="selflink">#</a></p><div class="doc"><p>Can be used to enumerate unbounded integrals. This does not check for
 overflow or underflow for bounded integrals.</p></div></div><div class="top"><p class="src"><a id="v:enumerateFromToIntegral" class="def">enumerateFromToIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a <a href="src/Streamly.Internal.Data.Unfold.html#enumerateFromToIntegral" class="link">Source</a> <a href="#v:enumerateFromToIntegral" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:enumerateFromIntegral" class="def">enumerateFromIntegral</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a a <a href="src/Streamly.Internal.Data.Unfold.html#enumerateFromIntegral" class="link">Source</a> <a href="#v:enumerateFromIntegral" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h1>Transformations</h1></a><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mapM" class="def">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#mapM" class="link">Source</a> <a href="#v:mapM" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mapMWithInput" class="def">mapMWithInput</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#mapMWithInput" class="link">Source</a> <a href="#v:mapMWithInput" class="selflink">#</a></p></div><a href="#g:6" id="g:6"><h1>Filtering</h1></a><div class="top"><p class="src"><a id="v:takeWhileM" class="def">takeWhileM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#takeWhileM" class="link">Source</a> <a href="#v:takeWhileM" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p></div><a href="#g:7" id="g:7"><h1>Nesting</h1></a><div class="top"><p class="src"><a id="v:concat" class="def">concat</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m b c -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#concat" class="link">Source</a> <a href="#v:concat" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m (<a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m () c)) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a c <a href="src/Streamly.Internal.Data.Unfold.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:outerProduct" class="def">outerProduct</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c d -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (a, c) (b, d) <a href="src/Streamly.Internal.Data.Unfold.html#outerProduct" class="link">Source</a> <a href="#v:outerProduct" class="selflink">#</a></p></div><a href="#g:8" id="g:8"><h1>Exceptions</h1></a><div class="top"><p class="src"><a id="v:gbracket" class="def">gbracket</a> <a href="src/Streamly.Internal.Data.Unfold.html#gbracket" class="link">Source</a> <a href="#v:gbracket" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; m c)</td><td class="doc"><p>before</p></td></tr><tr><td class="src">-&gt; (<span class="keyword">forall</span> s. m s -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e s))</td><td class="doc"><p>try (exception handling)</p></td></tr><tr><td class="src">-&gt; (c -&gt; m d)</td><td class="doc"><p>after, on normal stop</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m (c, e) b</td><td class="doc"><p>on exception</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b</td><td class="doc"><p>unfold to run</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The most general bracketing and exception combinator. All other
 combinators can be expressed in terms of this combinator. This can also be
 used for cases which are not covered by the standard combinators.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:before" class="def">before</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#before" class="link">Source</a> <a href="#v:before" class="selflink">#</a></p><div class="doc"><p>Run a side effect before the unfold yields its first element.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:after" class="def">after</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#after" class="link">Source</a> <a href="#v:after" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the unfold stops normally.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:onException" class="def">onException</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#onException" class="link">Source</a> <a href="#v:onException" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the unfold aborts due to an exception.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:finally" class="def">finally</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#finally" class="link">Source</a> <a href="#v:finally" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the unfold stops normally or aborts due to an
 exception.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:bracket" class="def">bracket</a> :: MonadCatch m =&gt; (a -&gt; m c) -&gt; (c -&gt; m d) -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m c b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#bracket" class="link">Source</a> <a href="#v:bracket" class="selflink">#</a></p><div class="doc"><p><code>bracket before after between</code> runs the <code>before</code> action and then unfolds
 its output using the <code>between</code> unfold. When the <code>between</code> unfold is done or
 if an exception occurs then the <code>after</code> action is run with the output of
 <code>before</code> as argument.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:handle" class="def">handle</a> :: (MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m e b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b -&gt; <a href="Streamly-Internal-Data-Unfold.html#t:Unfold" title="Streamly.Internal.Data.Unfold">Unfold</a> m a b <a href="src/Streamly.Internal.Data.Unfold.html#handle" class="link">Source</a> <a href="#v:handle" class="selflink">#</a></p><div class="doc"><p>When unfolding if an exception occurs, unfold the exception using the
 exception unfold supplied as the first argument to <code><a href="Streamly-Internal-Data-Unfold.html#v:handle" title="Streamly.Internal.Data.Unfold">handle</a></code>.</p><p><em>Internal</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>