<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Prelude</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Prelude.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-v0.7.0: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Harendra Kumar</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Prelude</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Construction</a><ul><li><a href="#g:2">Primitives</a></li><li><a href="#g:3">From Values</a></li><li><a href="#g:4">Enumeration</a></li><li><a href="#g:5">From Generators</a></li><li><a href="#g:6">From Containers</a></li></ul></li><li><a href="#g:7">Elimination</a><ul><li><a href="#g:8">Deconstruction</a></li><li><a href="#g:9">Folding</a></li><li><a href="#g:10">Right Folds</a></li><li><a href="#g:11">Left Folds</a></li><li><a href="#g:12">Full Folds</a></li><li><a href="#g:13">Partial Folds</a></li><li><a href="#g:14">To Containers</a></li><li><a href="#g:15">Composable Left Folds</a></li></ul></li><li><a href="#g:16">Transformation</a><ul><li><a href="#g:17">Mapping</a></li><li><a href="#g:18">Scanning</a></li><li><a href="#g:19">Left scans</a></li><li><a href="#g:20">Scan Using Fold</a></li><li><a href="#g:21">Indexing</a></li><li><a href="#g:22">Filtering</a></li><li><a href="#g:23">Stateful Filters</a></li><li><a href="#g:24">Mapping Filters</a></li><li><a href="#g:25">Scanning Filters</a></li><li><a href="#g:26">Insertion</a></li><li><a href="#g:27">Reordering</a></li></ul></li><li><a href="#g:28">Multi-Stream Operations</a><ul><li><a href="#g:29">Appending</a></li><li><a href="#g:30">Interleaving</a></li><li><a href="#g:31">Scheduling</a></li><li><a href="#g:32">Parallel</a></li><li><a href="#g:33">Merging</a></li><li><a href="#g:34">Zipping</a></li><li><a href="#g:35">Nested Streams</a></li><li><a href="#g:36">Splitting</a></li><li><a href="#g:37">Grouping</a></li><li><a href="#g:38">Distributing</a></li></ul></li><li><a href="#g:39">Windowed Classification</a><ul><li><a href="#g:40">Tumbling Windows</a></li><li><a href="#g:41">Keep Alive Windows</a></li><li><a href="#g:42">Sliding Window Buffers</a></li><li><a href="#g:43">Containers of Streams</a></li><li><a href="#g:44">Folding</a></li></ul></li><li><a href="#g:45">Exceptions</a></li><li><a href="#g:46">Generalize Inner Monad</a></li><li><a href="#g:47">Transform Inner Monad</a></li><li><a href="#g:48">Diagnostics</a></li><li><a href="#g:49">Deprecated</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:nil">nil</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a</li><li class="src short"><a href="#v:nilM">nilM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a</li><li class="src short"><a href="#v:cons">cons</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:.:">(.:)</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:consM">consM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:-124-:">(|:)</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:repeat">repeat</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:repeatM">repeatM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:replicate">replicate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; t m a</li><li class="src short"><a href="#v:replicateM">replicateM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a</li><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a =&gt; <a href="#t:Enumerable">Enumerable</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; a -&gt; t m a</li></ul></li><li class="src short"><a href="#v:enumerate">enumerate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> a) =&gt; t m a</li><li class="src short"><a href="#v:enumerateTo">enumerateTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> a) =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:unfoldr">unfoldr</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; t m a</li><li class="src short"><a href="#v:unfoldrM">unfoldrM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (b -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, b))) -&gt; b -&gt; t m a</li><li class="src short"><a href="#v:unfold">unfold</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; a -&gt; t m b</li><li class="src short"><a href="#v:iterate">iterate</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (a -&gt; a) -&gt; a -&gt; t m a</li><li class="src short"><a href="#v:iterateM">iterateM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m a) -&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:fromIndices">fromIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a) -&gt; t m a</li><li class="src short"><a href="#v:fromIndicesM">fromIndicesM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a) -&gt; t m a</li><li class="src short"><a href="#v:fromList">fromList</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; [a] -&gt; t m a</li><li class="src short"><a href="#v:fromListM">fromListM</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; [m a] -&gt; t m a</li><li class="src short"><a href="#v:fromFoldable">fromFoldable</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a</li><li class="src short"><a href="#v:fromFoldableM">fromFoldableM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f (m a) -&gt; t m a</li><li class="src short"><a href="#v:uncons">uncons</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, t m a))</li><li class="src short"><a href="#v:tail">tail</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:init">init</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:foldrM">foldrM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b -&gt; m b) -&gt; m b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldrS">foldrS</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldrT">foldrT</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b</li><li class="src short"><a href="#v:foldr">foldr</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldl-39-">foldl'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldl1-39-">foldl1'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:foldlM-39-">foldlM'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:drain">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:last">last</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:length">length</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:sum">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:product">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:maximumBy">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:maximum">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimumBy">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimum">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:the">the</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:drainN">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:drainWhile">drainWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:-33--33-">(!!)</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:head">head</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:findM">findM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:find">find</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:lookup">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m (a, b) -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:findIndex">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:elemIndex">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:null">null</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:elem">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:notElem">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:any">any</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:and">and</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:or">or</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:toList">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m [a]</li><li class="src short"><a href="#v:toListRev">toListRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m [a]</li><li class="src short"><a href="#v:toPure">toPure</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:toPureRev">toPureRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:toStream">toStream</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:toStreamRev">toStreamRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:transform">transform</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:map">map</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:sequence">sequence</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a</li><li class="src short"><a href="#v:mapM">mapM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mapM_">mapM_</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:scanl-39-">scanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlM-39-">scanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanl-39-">postscanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanlM-39-">postscanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanl-39-">prescanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanlM-39-">prescanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanl1-39-">scanl1'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scanl1M-39-">scanl1M'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scan">scan</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscan">postscan</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:indexed">indexed</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:indexedR">indexedR</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:filter">filter</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:filterM">filterM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:take">take</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhileM">takeWhileM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:drop">drop</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhile">dropWhile</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhileM">dropWhileM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:deleteBy">deleteBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:uniq">uniq</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mapMaybe">mapMaybe</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mapMaybeM">mapMaybeM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:findIndices">findIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:elemIndices">elemIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:insertBy">insertBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseM">intersperseM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperse">intersperse</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffix">intersperseSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interjectSuffix">interjectSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse">reverse</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse-39-">reverse'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:append">append</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleave">interleave</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveMin">interleaveMin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveSuffix">interleaveSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveInfix">interleaveInfix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:wSerialFst">wSerialFst</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialMin">wSerialMin</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:roundrobin">roundrobin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:parallelFst">parallelFst</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelMin">parallelMin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeBy">mergeBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeByM">mergeByM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncBy">mergeAsyncBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncByM">mergeAsyncByM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipWithM">zipWithM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWith">zipAsyncWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWithM">zipAsyncWithM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfold">concatUnfold</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldInterleave">concatUnfoldInterleave</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldRoundrobin">concatUnfoldRoundrobin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMapWith">concatMapWith</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (<span class="keyword">forall</span> c. t m c -&gt; t m c -&gt; t m c) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:gintercalate">gintercalate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalateSuffix">gintercalateSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalate">intercalate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalateSuffix">intercalateSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interpose">interpose</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interposeSuffix">interposeSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:splitAt">splitAt</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:span">span</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:break">break</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:spanBy">spanBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:spanByRolling">spanByRolling</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c)</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOf2">chunksOf2</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:arraysOf">arraysOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a)</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOn">splitOn</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffix">splitOnSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffix">splitWithSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:wordsBy">wordsBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffixSeq">splitOnSuffixSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitBySeq">splitBySeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffixSeq">splitWithSuffixSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitInnerBy">splitInnerBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:splitInnerBySuffix">splitInnerBySuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:groups">groups</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsBy">groupsBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsByRolling">groupsByRolling</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:trace">trace</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tap">tap</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapAsync">tapAsync</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:classifySessionsBy">classifySessionsBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifySessionsOf">classifySessionsOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifyKeepAliveSessions">classifyKeepAliveSessions</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:foldWith">foldWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a</li><li class="src short"><a href="#v:foldMapWith">foldMapWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b</li><li class="src short"><a href="#v:forEachWith">forEachWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:eqBy">eqBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:cmpBy">cmpBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></li><li class="src short"><a href="#v:isPrefixOf">isPrefixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isSubsequenceOf">isSubsequenceOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:stripPrefix">stripPrefix</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:before">before</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:after">after</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:bracket">bracket</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:onException">onException</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:finally">finally</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:handle">handle</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:hoist">hoist</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> n) =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> n a</li><li class="src short"><a href="#v:generally">generally</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m a</li><li class="src short"><a href="#v:liftInner">liftInner</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> tr, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (tr m)) =&gt; t m a -&gt; t (tr m) a</li><li class="src short"><a href="#v:runReaderT">runReaderT</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; s -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> s m) a -&gt; t m a</li><li class="src short"><a href="#v:evalStateT">evalStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a</li><li class="src short"><a href="#v:usingStateT">usingStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a</li><li class="src short"><a href="#v:runStateT">runStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m (s, a)</li><li class="src short"><a href="#v:inspectMode">inspectMode</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:once">once</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:each">each</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a</li><li class="src short"><a href="#v:scanx">scanx</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldx">foldx</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldxM">foldxM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldr1">foldr1</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:runStream">runStream</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:runN">runN</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:runWhile">runWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:fromHandle">fromHandle</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:toHandle">toHandle</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Construction</h1></a><a href="#g:2" id="g:2"><h2>Primitives</h2></a><div class="top"><p class="src"><a id="v:nil" class="def">nil</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a <a href="src/Streamly.Streams.StreamK.Type.html#nil" class="link">Source</a> <a href="#v:nil" class="selflink">#</a></p><div class="doc"><p>An empty stream.</p><pre>&gt; toList nil
[]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:nilM" class="def">nilM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a <a href="src/Streamly.Streams.StreamK.Type.html#nilM" class="link">Source</a> <a href="#v:nilM" class="selflink">#</a></p><div class="doc"><p>An empty stream producing a side effect.</p><pre>&gt; toList (nilM (print &quot;nil&quot;))
&quot;nil&quot;
[]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:cons" class="def">cons</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Streams.StreamK.Type.html#cons" class="link">Source</a> <a href="#v:cons" class="selflink">#</a></p><div class="doc"><p>Construct a stream by adding a pure value at the head of an existing
 stream. For serial streams this is the same as <code>(return a) `consM` r</code> but
 more efficient. For concurrent streams this is not concurrent whereas
 <code><a href="Streamly-Internal-Prelude.html#v:consM" title="Streamly.Internal.Prelude">consM</a></code> is concurrent. For example:</p><pre>&gt; toList $ 1 `cons` 2 `cons` 3 `cons` nil
[1,2,3]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:.:" class="def">(.:)</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Streams.StreamK.Type.html#.%3A" class="link">Source</a> <a href="#v:.:" class="selflink">#</a></p><div class="doc"><p>Operator equivalent of <code><a href="Streamly-Internal-Prelude.html#v:cons" title="Streamly.Internal.Prelude">cons</a></code>.</p><pre>&gt; toList $ 1 .: 2 .: 3 .: nil
[1,2,3]
</pre><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:consM" class="def">consM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Streams.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><div class="doc"><p>Constructs a stream by adding a monadic action at the head of an
 existing stream. For example:</p><pre>&gt; toList $ getLine `consM` getLine `consM` nil
hello
world
[&quot;hello&quot;,&quot;world&quot;]
</pre><p><em>Concurrent (do not use <code>parallely</code> to construct infinite streams)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:-124-:" class="def">(|:)</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Streams.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p><div class="doc"><p>Operator equivalent of <code><a href="Streamly-Internal-Prelude.html#v:consM" title="Streamly.Internal.Prelude">consM</a></code>. We can read it as &quot;<code>parallel colon</code>&quot;
 to remember that <code>|</code> comes before <code>:</code>.</p><pre>&gt; toList $ getLine |: getLine |: nil
hello
world
[&quot;hello&quot;,&quot;world&quot;]
</pre><pre>let delay = threadDelay 1000000 &gt;&gt; print 1
drain $ serially  $ delay |: delay |: delay |: nil
drain $ parallely $ delay |: delay |: delay |: nil
</pre><p><em>Concurrent (do not use <code>parallely</code> to construct infinite streams)</em></p><p><em>Since: 0.2.0</em></p></div></div><a href="#g:3" id="g:3"><h2>From Values</h2></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><pre>yield a = a `cons` nil
</pre><p>Create a singleton stream from a pure value.</p><p>The following holds in monadic streams, but not in Zip streams:</p><pre>yield = pure
yield = yieldM . pure
</pre><p>In Zip applicative streams <code><a href="Streamly-Internal-Prelude.html#v:yield" title="Streamly.Internal.Prelude">yield</a></code> is not the same as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> because in that
 case <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is equivalent to <code><a href="Streamly-Internal-Prelude.html#v:repeat" title="Streamly.Internal.Prelude">repeat</a></code> instead. <code><a href="Streamly-Internal-Prelude.html#v:yield" title="Streamly.Internal.Prelude">yield</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> are
 equally efficient, in other cases <code><a href="Streamly-Internal-Prelude.html#v:yield" title="Streamly.Internal.Prelude">yield</a></code> may be slightly more efficient
 than the other equivalent definitions.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><pre>yieldM m = m `consM` nil
</pre><p>Create a singleton stream from a monadic action.</p><pre>&gt; toList $ yieldM getLine
hello
[&quot;hello&quot;]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:repeat" class="def">repeat</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#repeat" class="link">Source</a> <a href="#v:repeat" class="selflink">#</a></p><div class="doc"><p>Generate an infinite stream by repeating a pure value.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:repeatM" class="def">repeatM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#repeatM" class="link">Source</a> <a href="#v:repeatM" class="selflink">#</a></p><div class="doc"><pre>repeatM = fix . consM
repeatM = cycle1 . yieldM
</pre><p>Generate a stream by repeatedly executing a monadic action forever.</p><pre>drain $ serially $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent, infinite (do not use with <code>parallely</code>)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:replicate" class="def">replicate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#replicate" class="link">Source</a> <a href="#v:replicate" class="selflink">#</a></p><div class="doc"><pre>replicate = take n . repeat
</pre><p>Generate a stream of length <code>n</code> by repeating a value <code>n</code> times.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:replicateM" class="def">replicateM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#replicateM" class="link">Source</a> <a href="#v:replicateM" class="selflink">#</a></p><div class="doc"><pre>replicateM = take n . repeatM
</pre><p>Generate a stream by performing a monadic action <code>n</code> times. Same as:</p><pre>drain $ serially $ S.replicateM 10 $ (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.replicateM 10 $ (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.1.1</em></p></div></div><a href="#g:4" id="g:4"><h2>Enumeration</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a =&gt; <a id="t:Enumerable" class="def">Enumerable</a> a <span class="keyword">where</span> <a href="src/Streamly.Streams.Enumeration.html#Enumerable" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></p><div class="doc"><p>Types that can be enumerated as a stream. The operations in this type
 class are equivalent to those in the <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a></code> type class, except that these
 generate a stream instead of a list. Use the functions in
 <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a> module to define new instances.</p><p><em>Since: 0.6.0</em></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:enumerateFrom" class="def">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><div class="doc"><p><code>enumerateFrom from</code> generates a stream starting with the element
 <code>from</code>, enumerating up to <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code> when the type is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> or
 generating an infinite stream when the type is not <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code>.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFrom (0 :: Int)
[0,1,2,3]
</pre><p>For <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> types, enumeration is numerically stable. However, no
 overflow or underflow checks are performed.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFrom 1.1
[1.1,2.1,3.1,4.1]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromTo" class="def">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><div class="doc"><p>Generate a finite stream starting with the element <code>from</code>, enumerating
 the type up to the value <code>to</code>. If <code>to</code> is smaller than <code>from</code> then an
 empty stream is returned.</p><pre>&gt; S.toList $ S.enumerateFromTo 0 4
[0,1,2,3,4]
</pre><p>For <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> types, the last element is equal to the specified <code>to</code>
 value after rounding to the nearest integral value.</p><pre>&gt; S.toList $ S.enumerateFromTo 1.1 4
[1.1,2.1,3.1,4.1]
&gt; S.toList $ S.enumerateFromTo 1.1 4.6
[1.1,2.1,3.1,4.1,5.1]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromThen" class="def">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><div class="doc"><p><code>enumerateFromThen from then</code> generates a stream whose first element
 is <code>from</code>, the second element is <code>then</code> and the successive elements are
 in increments of <code>then - from</code>.  Enumeration can occur downwards or
 upwards depending on whether <code>then</code> comes before or after <code>from</code>. For
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> types the stream ends when <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code> is reached, for
 unbounded types it keeps enumerating infinitely.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFromThen 0 2
[0,2,4,6]
&gt; S.toList $ S.take 4 $ S.enumerateFromThen 0 (-2)
[0,-2,-4,-6]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromThenTo" class="def">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p><div class="doc"><p><code>enumerateFromThenTo from then to</code> generates a finite stream whose
 first element is <code>from</code>, the second element is <code>then</code> and the successive
 elements are in increments of <code>then - from</code> up to <code>to</code>. Enumeration can
 occur downwards or upwards depending on whether <code>then</code> comes before or
 after <code>from</code>.</p><pre>&gt; S.toList $ S.enumerateFromThenTo 0 2 6
[0,2,4,6]
&gt; S.toList $ S.enumerateFromThenTo 0 (-2) (-6)
[0,-2,-4,-6]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="subs instances"><details id="i:Enumerable" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:1"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-466" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:2"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-468" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:3"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-521" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:4"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-520" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:5"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-482" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:6"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-483" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:7"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-484" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:8"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-485" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:9"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-486" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:10"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-506" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:11"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-507" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:12"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-467" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:13"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-487" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:14"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-488" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:15"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-489" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:16"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-490" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:17"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a></span> <a href="src/Streamly.Streams.Enumeration.html#line-491" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:18"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> ()</span> <a href="src/Streamly.Streams.Enumeration.html#line-465" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; t m () <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:19"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a)</span> <a href="src/Streamly.Streams.Enumeration.html#line-523" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:20"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:HasResolution" title="Data.Fixed">HasResolution</a> a =&gt; <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a)</span> <a href="src/Streamly.Streams.Enumeration.html#line-522" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:21"></span> <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> a =&gt; <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Streams.Enumeration.html#line-526" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Streams-Enumeration.html">Streamly.Streams.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Streams.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:enumerate" class="def">enumerate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> a) =&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerate" class="link">Source</a> <a href="#v:enumerate" class="selflink">#</a></p><div class="doc"><pre>enumerate = enumerateFrom minBound</pre><p>Enumerate a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> type from its <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:minBound" title="Prelude">minBound</a></code> to <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code></p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:enumerateTo" class="def">enumerateTo</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Prelude.html#t:Enumerable" title="Streamly.Internal.Prelude">Enumerable</a> a) =&gt; a -&gt; t m a <a href="src/Streamly.Streams.Enumeration.html#enumerateTo" class="link">Source</a> <a href="#v:enumerateTo" class="selflink">#</a></p><div class="doc"><pre>enumerateTo = enumerateFromTo minBound</pre><p>Enumerate a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> type from its <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:minBound" title="Prelude">minBound</a></code> to specified value.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:5" id="g:5"><h2>From Generators</h2></a><div class="top"><p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#unfoldr" class="link">Source</a> <a href="#v:unfoldr" class="selflink">#</a></p><div class="doc"><pre>unfoldr step s =
    case step s of
        Nothing -&gt; <code><a href="Streamly-Internal-Prelude.html#v:nil" title="Streamly.Internal.Prelude">nil</a></code>
        Just (a, b) -&gt; a `cons` unfoldr step b
</pre><p>Build a stream by unfolding a <em>pure</em> step function <code>step</code> starting from a
 seed <code>s</code>.  The step function returns the next element in the stream and the
 next seed value. When it is done it returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> and the stream ends.
 For example,</p><pre>let f b =
        if b &gt; 3
        then Nothing
        else Just (b, b + 1)
in toList $ unfoldr f 0
</pre><pre>[0,1,2,3]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfoldrM" class="def">unfoldrM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (b -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, b))) -&gt; b -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#unfoldrM" class="link">Source</a> <a href="#v:unfoldrM" class="selflink">#</a></p><div class="doc"><p>Build a stream by unfolding a <em>monadic</em> step function starting from a
 seed.  The step function returns the next element in the stream and the next
 seed value. When it is done it returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> and the stream ends. For
 example,</p><pre>let f b =
        if b &gt; 3
        then return Nothing
        else print b &gt;&gt; return (Just (b, b + 1))
in drain $ unfoldrM f 0
</pre><pre> 0
 1
 2
 3
</pre><p>When run concurrently, the next unfold step can run concurrently with the
 processing of the output of the previous step.  Note that more than one step
 cannot run concurrently as the next step depends on the output of the
 previous step.</p><pre>(asyncly $ S.unfoldrM (\n -&gt; liftIO (threadDelay 1000000) &gt;&gt; return (Just (n, n + 1))) 0)
    &amp; S.foldlM' (\_ a -&gt; threadDelay 1000000 &gt;&gt; print a) ()
</pre><p><em>Concurrent</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfold" class="def">unfold</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#unfold" class="link">Source</a> <a href="#v:unfold" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> into a stream by supplying it an input seed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unfold UF.replicateM 10 (putStrLn &quot;hello&quot;)
</code></strong></pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:iterate" class="def">iterate</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (a -&gt; a) -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#iterate" class="link">Source</a> <a href="#v:iterate" class="selflink">#</a></p><div class="doc"><pre>iterate f x = x `cons` iterate f x
</pre><p>Generate an infinite stream with <code>x</code> as the first element and each
 successive element derived by applying the function <code>f</code> on the previous
 element.</p><pre>&gt; S.toList $ S.take 5 $ S.iterate (+1) 1
[1,2,3,4,5]
</pre><p><em>Since: 0.1.2</em></p></div></div><div class="top"><p class="src"><a id="v:iterateM" class="def">iterateM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m a) -&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#iterateM" class="link">Source</a> <a href="#v:iterateM" class="selflink">#</a></p><div class="doc"><pre>iterateM f m = m &gt;&gt;= a -&gt; return a `consM` iterateM f (f a)
</pre><p>Generate an infinite stream with the first element generated by the action
 <code>m</code> and each successive element derived by applying the monadic function
 <code>f</code> on the previous element.</p><p>When run concurrently, the next iteration can run concurrently with the
 processing of the previous iteration. Note that more than one iteration
 cannot run concurrently as the next iteration depends on the output of the
 previous iteration.</p><pre>drain $ serially $ S.take 10 $ S.iterateM
     (\x -&gt; threadDelay 1000000 &gt;&gt; print x &gt;&gt; return (x + 1)) (return 0)

drain $ asyncly  $ S.take 10 $ S.iterateM
     (\x -&gt; threadDelay 1000000 &gt;&gt; print x &gt;&gt; return (x + 1)) (return 0)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.7.0 (signature change)</em></p><p><em>Since: 0.1.2</em></p></div></div><div class="top"><p class="src"><a id="v:fromIndices" class="def">fromIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a) -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#fromIndices" class="link">Source</a> <a href="#v:fromIndices" class="selflink">#</a></p><div class="doc"><pre>fromIndices f = let g i = f i `cons` g (i + 1) in g 0
</pre><p>Generate an infinite stream, whose values are the output of a function <code>f</code>
 applied on the corresponding index.  Index starts at 0.</p><pre>&gt; S.toList $ S.take 5 $ S.fromIndices id
[0,1,2,3,4]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromIndicesM" class="def">fromIndicesM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a) -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#fromIndicesM" class="link">Source</a> <a href="#v:fromIndicesM" class="selflink">#</a></p><div class="doc"><pre>fromIndicesM f = let g i = f i `consM` g (i + 1) in g 0
</pre><p>Generate an infinite stream, whose values are the output of a monadic
 function <code>f</code> applied on the corresponding index. Index starts at 0.</p><p><em>Concurrent</em></p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:6" id="g:6"><h2>From Containers</h2></a><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; [a] -&gt; t m a <a href="src/Streamly.Streams.Prelude.html#fromList" class="link">Source</a> <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><pre>fromList = <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Prelude.html#v:cons" title="Streamly.Internal.Prelude">cons</a></code> <code><a href="Streamly-Internal-Prelude.html#v:nil" title="Streamly.Internal.Prelude">nil</a></code>
</pre><p>Construct a stream from a list of pure values. This is more efficient than
 <code><a href="Streamly-Internal-Prelude.html#v:fromFoldable" title="Streamly.Internal.Prelude">fromFoldable</a></code> for serial streams.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromListM" class="def">fromListM</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; [m a] -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#fromListM" class="link">Source</a> <a href="#v:fromListM" class="selflink">#</a></p><div class="doc"><pre>fromListM = <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Prelude.html#v:consM" title="Streamly.Internal.Prelude">consM</a></code> <code><a href="Streamly-Internal-Prelude.html#v:nil" title="Streamly.Internal.Prelude">nil</a></code>
</pre><p>Construct a stream from a list of monadic actions. This is more efficient
 than <code><a href="Streamly-Internal-Prelude.html#v:fromFoldableM" title="Streamly.Internal.Prelude">fromFoldableM</a></code> for serial streams.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromFoldable" class="def">fromFoldable</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a <a href="src/Streamly.Streams.StreamK.html#fromFoldable" class="link">Source</a> <a href="#v:fromFoldable" class="selflink">#</a></p><div class="doc"><pre>fromFoldable = <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Prelude.html#v:cons" title="Streamly.Internal.Prelude">cons</a></code> <code><a href="Streamly-Internal-Prelude.html#v:nil" title="Streamly.Internal.Prelude">nil</a></code>
</pre><p>Construct a stream from a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> containing pure values:</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromFoldableM" class="def">fromFoldableM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f (m a) -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#fromFoldableM" class="link">Source</a> <a href="#v:fromFoldableM" class="selflink">#</a></p><div class="doc"><pre>fromFoldableM = <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Prelude.html#v:consM" title="Streamly.Internal.Prelude">consM</a></code> <code><a href="Streamly-Internal-Prelude.html#v:nil" title="Streamly.Internal.Prelude">nil</a></code>
</pre><p>Construct a stream from a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> containing monadic actions.</p><pre>drain $ serially $ S.fromFoldableM $ replicateM 10 (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.fromFoldableM $ replicateM 10 (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent (do not use with <code>parallely</code> on infinite containers)</em></p><p><em>Since: 0.3.0</em></p></div></div><a href="#g:7" id="g:7"><h1>Elimination</h1></a><a href="#g:8" id="g:8"><h2>Deconstruction</h2></a><div class="top"><p class="src"><a id="v:uncons" class="def">uncons</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (a, t m a)) <a href="src/Streamly.Internal.Prelude.html#uncons" class="link">Source</a> <a href="#v:uncons" class="selflink">#</a></p><div class="doc"><p>Decompose a stream into its head and tail. If the stream is empty, returns
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code>. If the stream is non-empty, returns <code>Just (a, ma)</code>, where <code>a</code> is
 the head of the stream and <code>ma</code> its tail.</p><p>This is a brute force primitive. Avoid using it as long as possible, use it
 when no other combinator can do the job. This can be used to do pretty much
 anything in an imperative manner, as it just breaks down the stream into
 individual elements and we can loop over them as we deem fit. For example,
 this can be used to convert a streamly stream into other stream types.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:tail" class="def">tail</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Prelude.html#tail" class="link">Source</a> <a href="#v:tail" class="selflink">#</a></p><div class="doc"><pre>tail = fmap (fmap snd) . uncons</pre><p>Extract all but the first element of the stream, if any.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:init" class="def">init</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Prelude.html#init" class="link">Source</a> <a href="#v:init" class="selflink">#</a></p><div class="doc"><p>Extract all but the last element of the stream, if any.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:9" id="g:9"><h2>Folding</h2></a><a href="#g:10" id="g:10"><h2>Right Folds</h2></a><div class="top"><p class="src"><a id="v:foldrM" class="def">foldrM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b -&gt; m b) -&gt; m b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldrM" class="link">Source</a> <a href="#v:foldrM" class="selflink">#</a></p><div class="doc"><p>Right associative/lazy pull fold. <code>foldrM build final stream</code> constructs
 an output structure using the step function <code>build</code>. <code>build</code> is invoked with
 the next input element and the remaining (lazy) tail of the output
 structure. It builds a lazy output expression using the two. When the &quot;tail
 structure&quot; in the output expression is evaluated it calls <code>build</code> again thus
 lazily consuming the input <code>stream</code> until either the output expression built
 by <code>build</code> is free of the &quot;tail&quot; or the input is exhausted in which case
 <code>final</code> is used as the terminating case for the output structure. For more
 details see the description in the previous section.</p><p>Example, determine if any element is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:odd" title="Prelude">odd</a></code> in a stream:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.foldrM (\x xs -&gt; if odd x then return True else xs) (return False) $ S.fromList (2:4:5:undefined)
</code></strong>&gt; True
</pre><p><em>Since: 0.7.0 (signature changed)</em></p><p><em>Since: 0.2.0 (signature changed)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldrS" class="def">foldrS</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#foldrS" class="link">Source</a> <a href="#v:foldrS" class="selflink">#</a></p><div class="doc"><p>Right fold to a streaming monad.</p><pre>foldrS S.cons S.nil === id</pre><p><code><a href="Streamly-Internal-Prelude.html#v:foldrS" title="Streamly.Internal.Prelude">foldrS</a></code> can be used to perform stateless stream to stream transformations
 like map and filter in general. It can be coupled with a scan to perform
 stateful transformations. However, note that the custom map and filter
 routines can be much more efficient than this due to better stream fusion.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS S.cons S.nil $ S.fromList [1..5]
</code></strong>&gt; [1,2,3,4,5]
</pre><p>Find if any element in the stream is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS (\x xs -&gt; if odd x then return True else xs) (return False) $ (S.fromList (2:4:5:undefined) :: SerialT IO Int)
</code></strong>&gt; [True]
</pre><p>Map (+2) on odd elements and filter out the even elements:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS (\x xs -&gt; if odd x then (x + 2) `S.cons` xs else xs) S.nil $ (S.fromList [1..5] :: SerialT IO Int)
</code></strong>&gt; [3,5,7]
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:foldrM" title="Streamly.Internal.Prelude">foldrM</a></code> can also be represented in terms of <code><a href="Streamly-Internal-Prelude.html#v:foldrS" title="Streamly.Internal.Prelude">foldrS</a></code>, however, the former
 is much more efficient:</p><pre>foldrM f z s = runIdentityT $ foldrS (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldrT" class="def">foldrT</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b <a href="src/Streamly.Internal.Prelude.html#foldrT" class="link">Source</a> <a href="#v:foldrT" class="selflink">#</a></p><div class="doc"><p>Right fold to a transformer monad.  This is the most general right fold
 function. <code><a href="Streamly-Internal-Prelude.html#v:foldrS" title="Streamly.Internal.Prelude">foldrS</a></code> is a special case of <code><a href="Streamly-Internal-Prelude.html#v:foldrT" title="Streamly.Internal.Prelude">foldrT</a></code>, however <code><a href="Streamly-Internal-Prelude.html#v:foldrS" title="Streamly.Internal.Prelude">foldrS</a></code>
 implementation can be more efficient:</p><pre>foldrS = foldrT
foldrM f z s = runIdentityT $ foldrT (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><code><a href="Streamly-Internal-Prelude.html#v:foldrT" title="Streamly.Internal.Prelude">foldrT</a></code> can be used to translate streamly streams to other transformer
 monads e.g.  to a different streaming type.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldr" class="def">foldr</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldr" class="link">Source</a> <a href="#v:foldr" class="selflink">#</a></p><div class="doc"><p>Right fold, lazy for lazy monads and pure streams, and strict for strict
 monads.</p><p>Please avoid using this routine in strict monads like IO unless you need a
 strict right fold. This is provided only for use in lazy monads (e.g.
 Identity) or pure streams. Note that with this signature it is not possible
 to implement a lazy foldr when the monad <code>m</code> is strict. In that case it
 would be strict in its accumulator and therefore would necessarily consume
 all its input.</p><p><em>Since: 0.1.0</em></p></div></div><a href="#g:11" id="g:11"><h2>Left Folds</h2></a><div class="top"><p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldl%27" class="link">Source</a> <a href="#v:foldl-39-" class="selflink">#</a></p><div class="doc"><p>Left associative/strict push fold. <code>foldl' reduce initial stream</code> invokes
 <code>reduce</code> with the accumulator and the next input in the input stream, using
 <code>initial</code> as the initial value of the current value of the accumulator. When
 the input is exhausted the current value of the accumulator is returned.
 Make sure to use a strict data structure for accumulator to not build
 unnecessary lazy expressions unless that's what you want. See the previous
 section for more details.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#foldl1%27" class="link">Source</a> <a href="#v:foldl1-39-" class="selflink">#</a></p><div class="doc"><p>Strict left fold, for non-empty streams, using first element as the
 starting value. Returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> if the stream is empty.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldlM-39-" class="def">foldlM'</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldlM%27" class="link">Source</a> <a href="#v:foldlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:foldl-39-" title="Streamly.Internal.Prelude">foldl'</a></code> but with a monadic step function.</p><p><em>Since: 0.2.0</em></p></div></div><a href="#g:12" id="g:12"><h2>Full Folds</h2></a><div class="top"><p class="src"><a id="v:drain" class="def">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#drain" class="link">Source</a> <a href="#v:drain" class="selflink">#</a></p><div class="doc"><pre>drain = mapM_ (\_ -&gt; return ())</pre><p>Run a stream, discarding the results. By default it interprets the stream
 as <code><a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a></code>, to run other types of streams use the type adapting
 combinators for example <code>drain . <code>asyncly</code></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:last" class="def">last</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p><div class="doc"><p>Extract the last element of the stream, if any.</p><pre>last xs = xs !! (length xs - 1)</pre><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:length" class="def">length</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Prelude.html#length" class="link">Source</a> <a href="#v:length" class="selflink">#</a></p><div class="doc"><p>Determine the length of the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:sum" class="def">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Prelude.html#sum" class="link">Source</a> <a href="#v:sum" class="selflink">#</a></p><div class="doc"><p>Determine the sum of all elements of a stream of numbers. Returns <code>0</code> when
 the stream is empty. Note that this is not numerically stable for floating
 point numbers.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:product" class="def">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Prelude.html#product" class="link">Source</a> <a href="#v:product" class="selflink">#</a></p><div class="doc"><p>Determine the product of all elements of a stream of numbers. Returns <code>1</code>
 when the stream is empty.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#maximumBy" class="link">Source</a> <a href="#v:maximumBy" class="selflink">#</a></p><div class="doc"><p>Determine the maximum element in a stream using the supplied comparison
 function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#maximum" class="link">Source</a> <a href="#v:maximum" class="selflink">#</a></p><div class="doc"><pre>maximum = <code><a href="Streamly-Internal-Prelude.html#v:maximumBy" title="Streamly.Internal.Prelude">maximumBy</a></code> compare
</pre><p>Determine the maximum element in a stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#minimumBy" class="link">Source</a> <a href="#v:minimumBy" class="selflink">#</a></p><div class="doc"><p>Determine the minimum element in a stream using the supplied comparison
 function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#minimum" class="link">Source</a> <a href="#v:minimum" class="selflink">#</a></p><div class="doc"><pre>minimum = <code><a href="Streamly-Internal-Prelude.html#v:minimumBy" title="Streamly.Internal.Prelude">minimumBy</a></code> compare
</pre><p>Determine the minimum element in a stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:the" class="def">the</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#the" class="link">Source</a> <a href="#v:the" class="selflink">#</a></p><div class="doc"><p>Ensures that all the elements of the stream are identical and then returns
 that unique element.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:13" id="g:13"><h2>Partial Folds</h2></a><div class="top"><p class="src"><a id="v:drainN" class="def">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#drainN" class="link">Source</a> <a href="#v:drainN" class="selflink">#</a></p><div class="doc"><pre>drainN n = drain . take n</pre><p>Run maximum up to <code>n</code> iterations of a stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:drainWhile" class="def">drainWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#drainWhile" class="link">Source</a> <a href="#v:drainWhile" class="selflink">#</a></p><div class="doc"><pre>drainWhile p = drain . takeWhile p</pre><p>Run a stream as long as the predicate holds true.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#%21%21" class="link">Source</a> <a href="#v:-33--33-" class="selflink">#</a></p><div class="doc"><p>Lookup the element at the given index.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:head" class="def">head</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#head" class="link">Source</a> <a href="#v:head" class="selflink">#</a></p><div class="doc"><p>Extract the first element of the stream, if any.</p><pre>head = (!! 0)</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:findM" class="def">findM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#findM" class="link">Source</a> <a href="#v:findM" class="selflink">#</a></p><div class="doc"><p>Returns the first element that satisfies the given predicate.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:find" class="def">find</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#find" class="link">Source</a> <a href="#v:find" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:findM" title="Streamly.Internal.Prelude">findM</a></code> but with a non-monadic predicate.</p><pre>find p = findM (return . p)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:lookup" class="def">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m (a, b) -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Prelude.html#lookup" class="link">Source</a> <a href="#v:lookup" class="selflink">#</a></p><div class="doc"><p>In a stream of (key-value) pairs <code>(a, b)</code>, return the value <code>b</code> of the
 first pair where the key equals the given value <code>a</code>.</p><pre>lookup = snd &lt;$&gt; find ((==) . fst)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:findIndex" class="def">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Prelude.html#findIndex" class="link">Source</a> <a href="#v:findIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index that satisfies the given predicate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Prelude.html#elemIndex" class="link">Source</a> <a href="#v:elemIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index where a given value is found in the stream.</p><pre>elemIndex a = findIndex (== a)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:null" class="def">null</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#null" class="link">Source</a> <a href="#v:null" class="selflink">#</a></p><div class="doc"><p>Determine whether the stream is empty.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:elem" class="def">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#elem" class="link">Source</a> <a href="#v:elem" class="selflink">#</a></p><div class="doc"><p>Determine whether an element is present in the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:notElem" class="def">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#notElem" class="link">Source</a> <a href="#v:notElem" class="selflink">#</a></p><div class="doc"><p>Determine whether an element is not present in the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><p>Determine whether all elements of a stream satisfy a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><p>Determine whether any of the elements of a stream satisfy a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:and" class="def">and</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#and" class="link">Source</a> <a href="#v:and" class="selflink">#</a></p><div class="doc"><p>Determines if all elements of a boolean stream are True.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:or" class="def">or</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#or" class="link">Source</a> <a href="#v:or" class="selflink">#</a></p><div class="doc"><p>Determines whether at least one element of a boolean stream is True.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:14" id="g:14"><h2>To Containers</h2></a><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m [a] <a href="src/Streamly.Internal.Prelude.html#toList" class="link">Source</a> <a href="#v:toList" class="selflink">#</a></p><div class="doc"><pre>toList = S.foldr (:) []
</pre><p>Convert a stream into a list in the underlying monad. The list can be
 consumed lazily in a lazy monad (e.g. <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code>). In a strict monad (e.g.
 IO) the whole list is generated and buffered before it can be consumed.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:toListRev" class="def">toListRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m [a] <a href="src/Streamly.Internal.Prelude.html#toListRev" class="link">Source</a> <a href="#v:toListRev" class="selflink">#</a></p><div class="doc"><pre>toListRev = S.foldl' (flip (:)) []
</pre><p>Convert a stream into a list in reverse order in the underlying monad.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toPure" class="def">toPure</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Prelude.html#toPure" class="link">Source</a> <a href="#v:toPure" class="selflink">#</a></p><div class="doc"><p>Convert a stream to a pure stream.</p><pre>toPure = foldr cons nil
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toPureRev" class="def">toPureRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Prelude.html#toPureRev" class="link">Source</a> <a href="#v:toPureRev" class="selflink">#</a></p><div class="doc"><p>Convert a stream to a pure stream in reverse order.</p><pre>toPureRev = foldl' (flip cons) nil
</pre><p><em>Internal</em></p></div></div><a href="#g:15" id="g:15"><h2>Composable Left Folds</h2></a><div class="top"><p class="src"><a id="v:fold" class="def">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#fold" class="link">Source</a> <a href="#v:fold" class="selflink">#</a></p><div class="doc"><p>Fold a stream using the supplied left fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold FL.sum (S.enumerateFromTo 1 100)
</code></strong>5050
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:toStream" class="def">toStream</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Prelude.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><div class="doc"><p>A fold that buffers its input to a pure stream.</p><p><em>Warning!</em> working on large streams accumulated as buffers in memory could
 be very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toStreamRev" class="def">toStreamRev</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Prelude.html#toStreamRev" class="link">Source</a> <a href="#v:toStreamRev" class="selflink">#</a></p><div class="doc"><p>Buffers the input stream to a pure stream in the reverse order of the
 input.</p><p><em>Warning!</em> working on large streams accumulated as buffers in memory could
 be very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Internal</em></p></div></div><a href="#g:16" id="g:16"><h1>Transformation</h1></a><div class="top"><p class="src"><a id="v:transform" class="def">transform</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#transform" class="link">Source</a> <a href="#v:transform" class="selflink">#</a></p><div class="doc"><p>Use a <code><a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a></code> to transform a stream.</p></div></div><a href="#g:17" id="g:17"><h2>Mapping</h2></a><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Streams.Serial.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><pre>map = fmap
</pre><p>Same as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><pre>&gt; S.toList $ S.map (+1) $ S.fromList [1,2,3]
[2,3,4]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><pre>sequence = mapM id
</pre><p>Replace the elements of a stream of monadic actions with the outputs of
 those actions.</p><pre>&gt; drain $ S.sequence $ S.fromList [putStr &quot;a&quot;, putStr &quot;b&quot;, putStrLn &quot;c&quot;]
abc

drain $ S.replicateM 10 (return $ threadDelay 1000000 &gt;&gt; print 1)
          &amp; (serially . S.sequence)

drain $ S.replicateM 10 (return $ threadDelay 1000000 &gt;&gt; print 1)
          &amp; (asyncly . S.sequence)
</pre><p><em>Concurrent (do not use with <code>parallely</code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapM" class="def">mapM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#mapM" class="link">Source</a> <a href="#v:mapM" class="selflink">#</a></p><div class="doc"><pre>mapM f = sequence . map f
</pre><p>Apply a monadic function to each element of the stream and replace it with
 the output of the resulting action.</p><pre>&gt; drain $ S.mapM putStr $ S.fromList [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
abc

drain $ S.replicateM 10 (return 1)
          &amp; (serially . S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x))

drain $ S.replicateM 10 (return 1)
          &amp; (asyncly . S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x))
</pre><p><em>Concurrent (do not use with <code>parallely</code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapM_" class="def">mapM_</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#mapM_" class="link">Source</a> <a href="#v:mapM_" class="selflink">#</a></p><div class="doc"><pre>mapM_ = drain . mapM</pre><p>Apply a monadic action to each element of the stream and discard the output
 of the action. This is not really a pure transformation operation but a
 transformation followed by fold.</p><p><em>Since: 0.1.0</em></p></div></div><a href="#g:18" id="g:18"><h2>Scanning</h2></a><a href="#g:19" id="g:19"><h2>Left scans</h2></a><div class="top"><p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#scanl%27" class="link">Source</a> <a href="#v:scanl-39-" class="selflink">#</a></p><div class="doc"><p>Strict left scan. Like <code>map</code>, <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> too is a one to one transformation,
 however it adds an extra element.</p><pre>&gt; S.toList $ S.scanl' (+) 0 $ fromList [1,2,3,4]
[0,1,3,6,10]
</pre><pre>&gt; S.toList $ S.scanl' (flip (:)) [] $ S.fromList [1,2,3,4]
[[],[1],[2,1],[3,2,1],[4,3,2,1]]
</pre><p>The output of <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> is the initial value of the accumulator followed by
 all the intermediate steps and the final result of <code><a href="Streamly-Internal-Prelude.html#v:foldl-39-" title="Streamly.Internal.Prelude">foldl'</a></code>.</p><p>By streaming the accumulated state after each fold step, we can share the
 state across multiple stages of stream composition. Each stage can modify or
 extend the state, do some processing with it and emit it for the next stage,
 thus modularizing the stream processing. This can be useful in
 stateful or event-driven programming.</p><p>Consider the following monolithic example, computing the sum and the product
 of the elements in a stream in one go using a <code>foldl'</code>:</p><pre>&gt; S.foldl' (\(s, p) x -&gt; (s + x, p * x)) (0,1) $ S.fromList [1,2,3,4]
(10,24)
</pre><p>Using <code>scanl'</code> we can make it modular by computing the sum in the first
 stage and passing it down to the next stage for computing the product:</p><pre>&gt;   S.foldl' (\(_, p) (s, x) -&gt; (s, p * x)) (0,1)
  $ S.scanl' (\(s, _) x -&gt; (s + x, x)) (0,1)
  $ S.fromList [1,2,3,4]
(10,24)
</pre><p>IMPORTANT: <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> evaluates the accumulator to WHNF.  To avoid building
 lazy expressions inside the accumulator, it is recommended that a strict
 data structure is used for accumulator.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanlM-39-" class="def">scanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#scanlM%27" class="link">Source</a> <a href="#v:scanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> but with a monadic fold function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscanl-39-" class="def">postscanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#postscanl%27" class="link">Source</a> <a href="#v:postscanl-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> but does not stream the initial value of the accumulator.</p><pre>postscanl' f z xs = S.drop 1 $ S.scanl' f z xs</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscanlM-39-" class="def">postscanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#postscanlM%27" class="link">Source</a> <a href="#v:postscanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:postscanl-39-" title="Streamly.Internal.Prelude">postscanl'</a></code> but with a monadic step function.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:prescanl-39-" class="def">prescanl'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#prescanl%27" class="link">Source</a> <a href="#v:prescanl-39-" class="selflink">#</a></p><div class="doc"><p>Like scanl' but does not stream the final value of the accumulator.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:prescanlM-39-" class="def">prescanlM'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#prescanlM%27" class="link">Source</a> <a href="#v:prescanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like postscanl' but with a monadic step function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1-39-" class="def">scanl1'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#scanl1%27" class="link">Source</a> <a href="#v:scanl1-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code> but for a non-empty stream. The first element of the stream
 is used as the initial value of the accumulator. Does nothing if the stream
 is empty.</p><pre>&gt; S.toList $ S.scanl1 (+) $ fromList [1,2,3,4]
[1,3,6,10]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1M-39-" class="def">scanl1M'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#scanl1M%27" class="link">Source</a> <a href="#v:scanl1M-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:scanl1-39-" title="Streamly.Internal.Prelude">scanl1'</a></code> but with a monadic step function.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:20" id="g:20"><h2>Scan Using Fold</h2></a><div class="top"><p class="src"><a id="v:scan" class="def">scan</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#scan" class="link">Source</a> <a href="#v:scan" class="selflink">#</a></p><div class="doc"><p>Scan a stream using the given monadic fold.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscan" class="def">postscan</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#postscan" class="link">Source</a> <a href="#v:postscan" class="selflink">#</a></p><div class="doc"><p>Postscan a stream using the given monadic fold.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:21" id="g:21"><h2>Indexing</h2></a><div class="top"><p class="src"><a id="v:indexed" class="def">indexed</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Prelude.html#indexed" class="link">Source</a> <a href="#v:indexed" class="selflink">#</a></p><div class="doc"><pre>indexed = S.postscanl' (\(i, _) x -&gt; (i + 1, x)) (-1,undefined)
indexed = S.zipWith (,) (S.enumerateFrom 0)</pre><p>Pair each element in a stream with its index, starting from index 0.</p><pre>&gt; S.toList $ S.indexed $ S.fromList &quot;hello&quot;
[(0,<code>h</code>),(1,<code>e</code>),(2,<code>l</code>),(3,<code>l</code>),(4,<code>o</code>)]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:indexedR" class="def">indexedR</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Prelude.html#indexedR" class="link">Source</a> <a href="#v:indexedR" class="selflink">#</a></p><div class="doc"><pre>indexedR n = S.postscanl' (\(i, _) x -&gt; (i - 1, x)) (n + 1,undefined)
indexedR n = S.zipWith (,) (S.enumerateFromThen n (n - 1))</pre><p>Pair each element in a stream with its index, starting from the
 given index <code>n</code> and counting down.</p><pre>&gt; S.toList $ S.indexedR 10 $ S.fromList &quot;hello&quot;
[(10,<code>h</code>),(9,<code>e</code>),(8,<code>l</code>),(7,<code>l</code>),(6,<code>o</code>)]
</pre><p><em>Since: 0.6.0</em></p></div></div><a href="#g:22" id="g:22"><h2>Filtering</h2></a><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Prelude.html#v:filter" title="Streamly.Internal.Prelude">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:23" id="g:23"><h2>Stateful Filters</h2></a><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>End the stream as soon as the predicate fails on an element.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileM" class="def">takeWhileM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#takeWhileM" class="link">Source</a> <a href="#v:takeWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Prelude.html#v:takeWhile" title="Streamly.Internal.Prelude">takeWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:drop" class="def">drop</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#drop" class="link">Source</a> <a href="#v:drop" class="selflink">#</a></p><div class="doc"><p>Discard first <code>n</code> elements from the stream and take the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#dropWhile" class="link">Source</a> <a href="#v:dropWhile" class="selflink">#</a></p><div class="doc"><p>Drop elements in the stream as long as the predicate succeeds and then
 take the rest of the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhileM" class="def">dropWhileM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#dropWhileM" class="link">Source</a> <a href="#v:dropWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Prelude.html#v:dropWhile" title="Streamly.Internal.Prelude">dropWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:deleteBy" class="def">deleteBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#deleteBy" class="link">Source</a> <a href="#v:deleteBy" class="selflink">#</a></p><div class="doc"><p>Deletes the first occurence of the element in the stream that satisfies
 the given equality predicate.</p><pre>&gt; S.toList $ S.deleteBy (==) 3 $ S.fromList [1,3,3,5]
[1,3,5]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:uniq" class="def">uniq</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#uniq" class="link">Source</a> <a href="#v:uniq" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements that are adjacent to each other.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:24" id="g:24"><h2>Mapping Filters</h2></a><div class="top"><p class="src"><a id="v:mapMaybe" class="def">mapMaybe</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#mapMaybe" class="link">Source</a> <a href="#v:mapMaybe" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a></code> returning function to a stream, filter out the <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code>
 elements, and return a stream of values extracted from <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Just" title="GHC.Maybe">Just</a></code>.</p><p>Equivalent to:</p><pre>mapMaybe f = S.map <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . S.filter <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . S.map f
</pre><p><em>Since: 0.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybeM" class="def">mapMaybeM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#mapMaybeM" class="link">Source</a> <a href="#v:mapMaybeM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:mapMaybe" title="Streamly.Internal.Prelude">mapMaybe</a></code> but maps a monadic function.</p><p>Equivalent to:</p><pre>mapMaybeM f = S.map <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . S.filter <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . S.mapM f
</pre><p><em>Concurrent (do not use with <code>parallely</code> on infinite streams)</em></p><p><em>Since: 0.3.0</em></p></div></div><a href="#g:25" id="g:25"><h2>Scanning Filters</h2></a><div class="top"><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Prelude.html#findIndices" class="link">Source</a> <a href="#v:findIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the element in the stream satisfies the given
 predicate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Prelude.html#elemIndices" class="link">Source</a> <a href="#v:elemIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the value of the element in the stream is equal
 to the given value.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:26" id="g:26"><h2>Insertion</h2></a><div class="top"><p class="src"><a id="v:insertBy" class="def">insertBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#insertBy" class="link">Source</a> <a href="#v:insertBy" class="selflink">#</a></p><div class="doc"><p><code>insertBy cmp elem stream</code> inserts <code>elem</code> before the first element in
 <code>stream</code> that is less than <code>elem</code> when compared using <code>cmp</code>.</p><pre>insertBy cmp x = <code><a href="Streamly-Internal-Prelude.html#v:mergeBy" title="Streamly.Internal.Prelude">mergeBy</a></code> cmp (<code><a href="Streamly-Internal-Prelude.html#v:yield" title="Streamly.Internal.Prelude">yield</a></code> x)
</pre><pre>&gt; S.toList $ S.insertBy compare 2 $ S.fromList [1,3,5]
[1,2,3,5]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM" class="def">intersperseM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#intersperseM" class="link">Source</a> <a href="#v:intersperseM" class="selflink">#</a></p><div class="doc"><p>Generate a stream by performing a monadic action between consecutive
 elements of the given stream.</p><p><em>Concurrent (do not use with <code>parallely</code> on infinite streams)</em></p><pre>&gt; S.toList $ S.intersperseM (return ',') $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperse" class="def">intersperse</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#intersperse" class="link">Source</a> <a href="#v:intersperse" class="selflink">#</a></p><div class="doc"><p>Generate a stream by inserting a given element between consecutive
 elements of the given stream.</p><pre>&gt; S.toList $ S.intersperse ',' $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffix" class="def">intersperseSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#intersperseSuffix" class="link">Source</a> <a href="#v:intersperseSuffix" class="selflink">#</a></p><div class="doc"><p>Insert a monadic action after each element in the stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:interjectSuffix" class="def">interjectSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#interjectSuffix" class="link">Source</a> <a href="#v:interjectSuffix" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 seconds.</p><pre>&gt; S.drain $ S.interjectSuffix 1 (putChar ',') $ S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; putChar x) $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:27" id="g:27"><h2>Reordering</h2></a><div class="top"><p class="src"><a id="v:reverse" class="def">reverse</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#reverse" class="link">Source</a> <a href="#v:reverse" class="selflink">#</a></p><div class="doc"><p>Returns the elements of the stream in reverse order.  The stream must be
 finite. Note that this necessarily buffers the entire stream in memory.</p><p><em>Since 0.7.0 (Monad m constraint)</em></p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:reverse-39-" class="def">reverse'</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#reverse%27" class="link">Source</a> <a href="#v:reverse-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:reverse" title="Streamly.Internal.Prelude">reverse</a></code> but several times faster, requires a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> instance.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:28" id="g:28"><h1>Multi-Stream Operations</h1></a><a href="#g:29" id="g:29"><h2>Appending</h2></a><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#append" class="link">Source</a> <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>Append the outputs of two streams, yielding all the elements from the
 first stream and then yielding all the elements from the second stream.</p><p>IMPORTANT NOTE: This could be 100x faster than <code>serial/&lt;&gt;</code> for appending a
 few (say 100) streams because it can fuse via stream fusion. However, it
 does not scale for a large number of streams (say 1000s) and becomes
 qudartically slow. Therefore use this for custom appending of a few streams
 but use <code><a href="Streamly-Internal-Prelude.html#v:concatMap" title="Streamly.Internal.Prelude">concatMap</a></code> or 'concatMapWith serial' for appending <code>n</code> streams or
 infinite containers of streams.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:30" id="g:30"><h2>Interleaving</h2></a><div class="top"><p class="src"><a id="v:interleave" class="def">interleave</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. If any of the streams finishes
 early the other stream continues alone until it too finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,,,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,cd&quot;
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:interleave" title="Streamly.Internal.Prelude">interleave</a></code> is dual to <code><a href="Streamly-Internal-Prelude.html#v:interleaveMin" title="Streamly.Internal.Prelude">interleaveMin</a></code>, it can be called <code>interleaveMax</code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveMin" class="def">interleaveMin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#interleaveMin" class="link">Source</a> <a href="#v:interleaveMin" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. The output stops as soon as any
 of the two streams finishes, discarding the remaining part of the other
 stream. The last element of the resulting stream would be from the longer
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:interleaveMin" title="Streamly.Internal.Prelude">interleaveMin</a></code> is dual to <code><a href="Streamly-Internal-Prelude.html#v:interleave" title="Streamly.Internal.Prelude">interleave</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveSuffix" class="def">interleaveSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#interleaveSuffix" class="link">Source</a> <a href="#v:interleaveSuffix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. As soon as the first stream
 finishes, the output stops, discarding the remaining part of the second
 stream. In this case, the last element in the resulting stream would be from
 the second stream. If the second stream finishes early then the first stream
 still continues to yield elements until it finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:interleaveSuffix" title="Streamly.Internal.Prelude">interleaveSuffix</a></code> is a dual of <code><a href="Streamly-Internal-Prelude.html#v:interleaveInfix" title="Streamly.Internal.Prelude">interleaveInfix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveInfix" class="def">interleaveInfix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#interleaveInfix" class="link">Source</a> <a href="#v:interleaveInfix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream and ending at the first stream.
 If the second stream is longer than the first, elements from the second
 stream are infixed with elements from the first stream. If the first stream
 is longer then it continues yielding elements even after the second stream
 has finished.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:interleaveInfix" title="Streamly.Internal.Prelude">interleaveInfix</a></code> is a dual of <code><a href="Streamly-Internal-Prelude.html#v:interleaveSuffix" title="Streamly.Internal.Prelude">interleaveSuffix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialFst" class="def">wSerialFst</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Serial.html#wSerialFst" class="link">Source</a> <a href="#v:wSerialFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly.html#v:wSerial" title="Streamly">wSerial</a></code> but stops interleaving as soon as the first stream stops.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialMin" class="def">wSerialMin</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Serial.html#wSerialMin" class="link">Source</a> <a href="#v:wSerialMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly.html#v:wSerial" title="Streamly">wSerial</a></code> but stops interleaving as soon as any of the two streams
 stops.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:31" id="g:31"><h2>Scheduling</h2></a><div class="top"><p class="src"><a id="v:roundrobin" class="def">roundrobin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#roundrobin" class="link">Source</a> <a href="#v:roundrobin" class="selflink">#</a></p><div class="doc"><p>Schedule the execution of two streams in a fair round-robin manner,
 executing each stream once, alternately. Execution of a stream may not
 necessarily result in an output, a stream may chose to <code>Skip</code> producing an
 element until later giving the other stream a chance to run. Therefore, this
 combinator fairly interleaves the execution of two streams rather than
 fairly interleaving the output of the two streams. This can be useful in
 co-operative multitasking without using explicit threads. This can be used
 as an alternative to <code>async</code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:32" id="g:32"><h2>Parallel</h2></a><div class="top"><p class="src"><a id="v:parallelFst" class="def">parallelFst</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Parallel.html#parallelFst" class="link">Source</a> <a href="#v:parallelFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly.html#v:parallel" title="Streamly">parallel</a></code> but stops the output as soon as the first stream stops.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallelMin" class="def">parallelMin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Parallel.html#parallelMin" class="link">Source</a> <a href="#v:parallelMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly.html#v:parallel" title="Streamly">parallel</a></code> but stops the output as soon as any of the two streams
 stops.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:33" id="g:33"><h2>Merging</h2></a><div class="top"><p class="src"><a id="v:mergeBy" class="def">mergeBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#mergeBy" class="link">Source</a> <a href="#v:mergeBy" class="selflink">#</a></p><div class="doc"><p>Merge two streams using a comparison function. The head elements of both
 the streams are compared and the smaller of the two elements is emitted, if
 both elements are equal then the element from the first stream is used
 first.</p><p>If the streams are sorted in ascending order, the resulting stream would
 also remain sorted in ascending order.</p><pre>&gt; S.toList $ S.mergeBy compare (S.fromList [1,3,5]) (S.fromList [2,4,6,8])
[1,2,3,4,5,6,8]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeByM" class="def">mergeByM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#mergeByM" class="link">Source</a> <a href="#v:mergeByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:mergeBy" title="Streamly.Internal.Prelude">mergeBy</a></code> but with a monadic comparison function.</p><p>Merge two streams randomly:</p><pre>&gt; randomly _ _ = randomIO &gt;&gt;= x -&gt; return $ if x then LT else GT
&gt; S.toList $ S.mergeByM randomly (S.fromList [1,1,1,1]) (S.fromList [2,2,2,2])
[2,1,2,2,2,1,1,1]
</pre><p>Merge two streams in a proportion of 2:1:</p><pre>proportionately m n = do
 ref &lt;- newIORef $ cycle $ concat [replicate m LT, replicate n GT]
 return $ \_ _ -&gt; do
     r &lt;- readIORef ref
     writeIORef ref $ tail r
     return $ head r

main = do
 f &lt;- proportionately 2 1
 xs &lt;- S.toList $ S.mergeByM f (S.fromList [1,1,1,1,1,1]) (S.fromList [2,2,2])
 print xs
</pre><pre>[1,1,2,1,1,2,1,1,2]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncBy" class="def">mergeAsyncBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#mergeAsyncBy" class="link">Source</a> <a href="#v:mergeAsyncBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:mergeBy" title="Streamly.Internal.Prelude">mergeBy</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncByM" class="def">mergeAsyncByM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#mergeAsyncByM" class="link">Source</a> <a href="#v:mergeAsyncByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:mergeByM" title="Streamly.Internal.Prelude">mergeByM</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:34" id="g:34"><h2>Zipping</h2></a><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>Zip two streams serially using a pure zipping function.</p><pre>&gt; S.toList $ S.zipWith (+) (S.fromList [1,2,3]) (S.fromList [4,5,6])
[5,7,9]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithM" class="def">zipWithM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#zipWithM" class="link">Source</a> <a href="#v:zipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:zipWith" title="Streamly.Internal.Prelude">zipWith</a></code> but using a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWith" class="def">zipAsyncWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Streams.Zip.html#zipAsyncWith" class="link">Source</a> <a href="#v:zipAsyncWith" class="selflink">#</a></p><div class="doc"><p>Like <code>zipWith</code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWithM" class="def">zipAsyncWithM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Streams.Zip.html#zipAsyncWithM" class="link">Source</a> <a href="#v:zipAsyncWithM" class="selflink">#</a></p><div class="doc"><p>Like <code>zipWithM</code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:35" id="g:35"><h2>Nested Streams</h2></a><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="Streamly-Internal-Prelude.html#v:concatMap" title="Streamly.Internal.Prelude">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfold" class="def">concatUnfold</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatUnfold" class="link">Source</a> <a href="#v:concatUnfold" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:concatMap" title="Streamly.Internal.Prelude">concatMap</a></code> but uses an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> for stream generation. Unlike
 <code><a href="Streamly-Internal-Prelude.html#v:concatMap" title="Streamly.Internal.Prelude">concatMap</a></code> this can fuse the <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> code with the inner loop and
 therefore provide many times better performance.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldInterleave" class="def">concatUnfoldInterleave</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatUnfoldInterleave" class="link">Source</a> <a href="#v:concatUnfoldInterleave" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:concatUnfold" title="Streamly.Internal.Prelude">concatUnfold</a></code> but interleaves the streams in the same way as
 <code><a href="Streamly-Internal-Prelude.html#v:interleave" title="Streamly.Internal.Prelude">interleave</a></code> behaves instead of appending them.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldRoundrobin" class="def">concatUnfoldRoundrobin</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatUnfoldRoundrobin" class="link">Source</a> <a href="#v:concatUnfoldRoundrobin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:concatUnfold" title="Streamly.Internal.Prelude">concatUnfold</a></code> but executes the streams in the same way as
 <code><a href="Streamly-Internal-Prelude.html#v:roundrobin" title="Streamly.Internal.Prelude">roundrobin</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a stream producing function on each element of the stream and then
 flatten the results into a single stream.</p><pre>concatMap = <code><a href="Streamly-Internal-Prelude.html#v:concatMapWith" title="Streamly.Internal.Prelude">concatMapWith</a></code> <code><a href="Streamly.html#v:serial" title="Streamly">serial</a></code>
concatMap f = <code><a href="Streamly-Internal-Prelude.html#v:concatMapM" title="Streamly.Internal.Prelude">concatMapM</a></code> (return . f)
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapWith" class="def">concatMapWith</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; (<span class="keyword">forall</span> c. t m c -&gt; t m c -&gt; t m c) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#concatMapWith" class="link">Source</a> <a href="#v:concatMapWith" class="selflink">#</a></p><div class="doc"><p><code>concatMapWith merge map stream</code> is a two dimensional looping combinator.
 The first argument specifies a merge or concat function that is used to
 merge the streams generated by applying the second argument i.e. the <code>map</code>
 function to each element of the input stream. The concat function could be
 <code>serial</code>, <code>parallel</code>, <code>async</code>, <code>ahead</code> or any other zip or merge function
 and the second argument could be any stream generation function using a
 seed.</p><p><em>Compare <code><a href="Streamly-Internal-Prelude.html#v:foldMapWith" title="Streamly.Internal.Prelude">foldMapWith</a></code></em></p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalate" class="def">gintercalate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#gintercalate" class="link">Source</a> <a href="#v:gintercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Prelude.html#v:interleaveInfix" title="Streamly.Internal.Prelude">interleaveInfix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalateSuffix" class="def">gintercalateSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#gintercalateSuffix" class="link">Source</a> <a href="#v:gintercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Prelude.html#v:interleaveSuffix" title="Streamly.Internal.Prelude">interleaveSuffix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intercalate" class="def">intercalate</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#intercalate" class="link">Source</a> <a href="#v:intercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Prelude.html#v:intersperse" title="Streamly.Internal.Prelude">intersperse</a></code> followed by unfold and concat.</p><pre>unwords = intercalate &quot; &quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot; &quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc def ghi&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:intercalateSuffix" class="def">intercalateSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#intercalateSuffix" class="link">Source</a> <a href="#v:intercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Prelude.html#v:intersperseSuffix" title="Streamly.Internal.Prelude">intersperseSuffix</a></code> followed by unfold and concat.</p><pre>unlines = intercalateSuffix &quot;\n&quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot;\n&quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc\ndef\nghi\n&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:interpose" class="def">interpose</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#interpose" class="link">Source</a> <a href="#v:interpose" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, intersperse the given element between the
 unfolded streams and then concat them into a single stream.</p><pre>unwords = S.interpose ' '</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interposeSuffix" class="def">interposeSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Prelude.html#interposeSuffix" class="link">Source</a> <a href="#v:interposeSuffix" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, append the given element after each
 unfolded stream and then concat them into a single stream.</p><pre>unlines = S.interposeSuffix '\n'</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Prelude.html#splitAt" class="link">Source</a> <a href="#v:splitAt" class="selflink">#</a></p><div class="doc"><p><code>splitAt n f1 f2</code> composes folds <code>f1</code> and <code>f2</code> such that first <code>n</code>
 elements of its input are consumed by fold <code>f1</code> and the rest of the stream
 is consumed by fold <code>f2</code>.</p><pre>let splitAt_ n xs = S.fold (FL.splitAt n FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 6 &quot;Hello World!&quot;
</code></strong>&gt; (&quot;Hello &quot;,&quot;World!&quot;)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ (-1) [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 0 [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 1 [1,2,3]
</code></strong>&gt; ([1],[2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 3 [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitAt_ 4 [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:span" class="def">span</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Prelude.html#span" class="link">Source</a> <a href="#v:span" class="selflink">#</a></p><div class="doc"><p><code>span p f1 f2</code> composes folds <code>f1</code> and <code>f2</code> such that <code>f1</code> consumes the
 input as long as the predicate <code>p</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>.  <code>f2</code> consumes the rest of the
 input.</p><pre>let span_ p xs = S.fold (S.span p FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 1) [1,2,3]
</code></strong>&gt; ([],[1,2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 2) [1,2,3]
</code></strong>&gt; ([1],[2,3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>span_ (&lt; 4) [1,2,3]
</code></strong>&gt; ([1,2,3],[])
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:break" class="def">break</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Prelude.html#break" class="link">Source</a> <a href="#v:break" class="selflink">#</a></p><div class="doc"><pre>break p = span (not . p)</pre><p>Break as soon as the predicate becomes <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. <code>break p f1 f2</code> composes
 folds <code>f1</code> and <code>f2</code> such that <code>f1</code> stops consuming input as soon as the
 predicate <code>p</code> becomes <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. The rest of the input is consumed <code>f2</code>.</p><p>This is the binary version of <code>splitBy</code>.</p><pre>let break_ p xs = S.fold (S.break p FL.toList FL.toList) $ S.fromList xs</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 1) [3,2,1]
</code></strong>&gt; ([3,2,1],[])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 2) [3,2,1]
</code></strong>&gt; ([3,2],[1])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>break_ (&lt; 4) [3,2,1]
</code></strong>&gt; ([],[3,2,1])
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:spanBy" class="def">spanBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Prelude.html#spanBy" class="link">Source</a> <a href="#v:spanBy" class="selflink">#</a></p><div class="doc"><p>Break the input stream into two groups, the first group takes the input as
 long as the predicate applied to the first element of the stream and next
 input element holds <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the second group takes the rest of the input.</p></div></div><div class="top"><p class="src"><a id="v:spanByRolling" class="def">spanByRolling</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (b, c) <a href="src/Streamly.Internal.Prelude.html#spanByRolling" class="link">Source</a> <a href="#v:spanByRolling" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:spanBy" title="Streamly.Internal.Prelude">spanBy</a></code> but applies the predicate in a rolling fashion i.e.
 predicate is applied to the previous and the next input elements.</p></div></div><a href="#g:36" id="g:36"><h2>Splitting</h2></a><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into groups of <code>n</code> elements each and then fold each
 group using the provided fold function.</p><pre>&gt; S.toList $ S.chunksOf 2 FL.sum (S.enumerateFromTo 1 10)
 [3,7,11,15,19]</pre><p>This can be considered as an n-fold version of <code>ltake</code> where we apply
 <code>ltake</code> repeatedly on the leftover stream until the stream exhausts.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf2" class="def">chunksOf2</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#chunksOf2" class="link">Source</a> <a href="#v:chunksOf2" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:arraysOf" class="def">arraysOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) <a href="src/Streamly.Internal.Prelude.html#arraysOf" class="link">Source</a> <a href="#v:arraysOf" class="selflink">#</a></p><div class="doc"><p><code>arraysOf n stream</code> groups the elements in the input stream into arrays of
 <code>n</code> elements each.</p><p>Same as the following but may be more efficient:</p><pre>arraysOf n = S.chunksOf n (A.writeN n)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of <code>n</code> second each and then fold each
 group using the provided fold function.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOn" class="def">splitOn</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitOn" class="link">Source</a> <a href="#v:splitOn" class="selflink">#</a></p><div class="doc"><p>Split on an infixed separator element, dropping the separator. Splits the
 stream on separator elements determined by the supplied predicate, separator
 is considered as infixed between two segments, if one side of the separator
 is missing then it is parsed as an empty stream.  The supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> is
 applied on the split segments. With <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing non-separator elements
 and <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Prelude.html#v:splitOn" title="Streamly.Internal.Prelude">splitOn</a></code> splits as follows:</p><pre>&quot;--.--&quot; =&gt; &quot;--&quot; &quot;--&quot;
&quot;--.&quot;   =&gt; &quot;--&quot; &quot;&quot;
&quot;.--&quot;   =&gt; &quot;&quot;   &quot;--&quot;
</pre><p><code>splitOn (== x)</code> is an inverse of <code>intercalate (S.yield x)</code></p><p>Let's use the following definition for illustration:</p><pre>splitOn' p xs = S.toList $ S.splitOn p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffix" class="def">splitOnSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitOnSuffix" class="link">Source</a> <a href="#v:splitOnSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitOn" title="Streamly.Internal.Prelude">splitOn</a></code> but the separator is considered as suffixed to the segments
 in the stream. A missing suffix at the end is allowed. A separator at the
 beginning is parsed as empty segment.  With <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing elements and
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Prelude.html#v:splitOnSuffix" title="Streamly.Internal.Prelude">splitOnSuffix</a></code> splits as follows:</p><pre> &quot;--.--.&quot; =&gt; &quot;--&quot; &quot;--&quot;
 &quot;--.--&quot;  =&gt; &quot;--&quot; &quot;--&quot;
 &quot;.--.&quot;   =&gt; &quot;&quot; &quot;--&quot;
</pre><pre>splitOnSuffix' p xs = S.toList $ S.splitSuffixBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitOnSuffix (== '\n')</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffix" class="def">splitWithSuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitWithSuffix" class="link">Source</a> <a href="#v:splitWithSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitOnSuffix" title="Streamly.Internal.Prelude">splitOnSuffix</a></code> but keeps the suffix attached to the resulting
 splits.</p><pre>splitWithSuffix' p xs = S.toList $ S.splitWithSuffix p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wordsBy" class="def">wordsBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#wordsBy" class="link">Source</a> <a href="#v:wordsBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitOn" title="Streamly.Internal.Prelude">splitOn</a></code> after stripping leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><pre>wordsBy' p xs = S.toList $ S.wordsBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,a,,b,&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre>words = wordsBy isSpace</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitOn" title="Streamly.Internal.Prelude">splitOn</a></code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre>splitOnSeq' pat xs = S.toList $ S.splitOnSeq (A.fromList pat) (FL.toList) (S.fromList xs)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Prelude.html#v:splitOnSeq" title="Streamly.Internal.Prelude">splitOnSeq</a></code> is an inverse of <code><a href="Streamly-Internal-Prelude.html#v:intercalate" title="Streamly.Internal.Prelude">intercalate</a></code>. The following law always holds:</p><pre>intercalate . splitOn == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOn . intercalate == id</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffixSeq" class="def">splitOnSuffixSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitOnSuffixSeq" class="link">Source</a> <a href="#v:splitOnSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixBy</code> but the separator is a sequence of elements, instead
 of a predicate for a single element.</p><pre>splitSuffixOn_ pat xs = S.toList $ S.splitSuffixOn (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitSuffixOn &quot;\n&quot;</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitBySeq" class="def">splitBySeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitBySeq" class="link">Source</a> <a href="#v:splitBySeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitOnSeq" title="Streamly.Internal.Prelude">splitOnSeq</a></code> but splits the separator as well, as an infix token.</p><pre>splitOn'_ pat xs = S.toList $ S.splitOn' (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;&quot;,&quot;e&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;hello&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;h&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;o&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;ll&quot;,&quot;o&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffixSeq" class="def">splitWithSuffixSeq</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#splitWithSuffixSeq" class="link">Source</a> <a href="#v:splitWithSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixOn</code> but keeps the suffix intact in the splits.</p><pre>splitSuffixOn'_ pat xs = S.toList $ FL.splitSuffixOn' (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBy" class="def">splitInnerBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Prelude.html#splitInnerBy" class="link">Source</a> <a href="#v:splitInnerBy" class="selflink">#</a></p><div class="doc"><p>Consider a chunked stream of container elements e.g. a stream of <code>Word8</code>
 chunked as a stream of arrays of <code>Word8</code>.  <code>splitInnerBy splitter joiner
 stream</code> splits the inner containers <code>f a</code> using the <code>splitter</code> function and
 joins back the resulting fragments from splitting across multiple containers
 using the <code>joiner</code> function such that the transformed output stream is
 consolidated as one container per segment of the split.</p><p>CAUTION! This is not a true streaming function as the container size after
 the split and merge may not be bounded.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBySuffix" class="def">splitInnerBySuffix</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Prelude.html#splitInnerBySuffix" class="link">Source</a> <a href="#v:splitInnerBySuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:splitInnerBy" title="Streamly.Internal.Prelude">splitInnerBy</a></code> but splits assuming the separator joins the segment in
 a suffix style.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:37" id="g:37"><h2>Grouping</h2></a><div class="top"><p class="src"><a id="v:groups" class="def">groups</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#groups" class="link">Source</a> <a href="#v:groups" class="selflink">#</a></p><div class="doc"><pre>groups = groupsBy (==)
groups = groupsByRolling (==)</pre><p>Groups contiguous spans of equal elements together in individual groups.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groups FL.toList $ S.fromList [1,1,2,2]
</code></strong>&gt; [[1,1],[2,2]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsBy" class="def">groupsBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#groupsBy" class="link">Source</a> <a href="#v:groupsBy" class="selflink">#</a></p><div class="doc"><p><code>groupsBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, if <code>a `cmp` b</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same
 group.  If <code>a `cmp` c</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the fold <code>f</code> and the result of the fold is emitted in
 the output stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsBy (&gt;) FL.toList $ S.fromList [1,3,7,0,2,5]
</code></strong>&gt; [[1,3,7],[0,2,5]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsByRolling" class="def">groupsByRolling</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#groupsByRolling" class="link">Source</a> <a href="#v:groupsByRolling" class="selflink">#</a></p><div class="doc"><p>Unlike <code>groupsBy</code> this function performs a rolling comparison of two
 successive elements in the input stream. <code>groupsByRolling cmp f $ S.fromList
 [a,b,c,...]</code> assigns the element <code>a</code> to the first group, if <code>a `cmp` b</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same group.  If <code>b `cmp` c</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same group and so on. When the
 comparison fails a new group is started. Each group is folded using the fold
 <code>f</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsByRolling (\a b -&gt; a + 1 == b) FL.toList $ S.fromList [1,2,3,7,8,9]
</code></strong>&gt; [[1,2,3],[7,8,9]]
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:38" id="g:38"><h2>Distributing</h2></a><div class="top"><p class="src"><a id="v:trace" class="def">trace</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#trace" class="link">Source</a> <a href="#v:trace" class="selflink">#</a></p><div class="doc"><p>Apply a monadic function to each element flowing through the stream and
 discard the results.</p><pre>&gt; S.drain $ S.trace print (S.enumerateFromTo 1 2)
1
2
</pre><p>Compare with <code><a href="Streamly-Internal-Prelude.html#v:tap" title="Streamly.Internal.Prelude">tap</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:tap" class="def">tap</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#tap" class="link">Source</a> <a href="#v:tap" class="selflink">#</a></p><div class="doc"><p>Tap the data flowing through a stream into a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. For example, you may
 add a tap to log the contents flowing through the stream. The fold is used
 only for effects, its result is discarded.</p><pre>                  Fold m a b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt; S.drain $ S.tap (FL.drainBy print) (S.enumerateFromTo 1 2)
1
2
</pre><p>Compare with <code><a href="Streamly-Internal-Prelude.html#v:trace" title="Streamly.Internal.Prelude">trace</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:tapAsync" class="def">tapAsync</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Parallel.html#tapAsync" class="link">Source</a> <a href="#v:tapAsync" class="selflink">#</a></p><div class="doc"><p>Redirect a copy of the stream to a supplied fold and run it concurrently
 in an independent thread. The fold may buffer some elements. The buffer size
 is determined by the prevailing <code>maxBuffer</code> setting.</p><pre>              Stream m a -&gt; m b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt; S.drain $ S.tapAsync (S.mapM_ print) (S.enumerateFromTo 1 2)
1
2
</pre><p>Exceptions from the concurrently running fold are propagated to the current
 computation.  Note that, because of buffering in the fold, exceptions may be
 delayed and may not correspond to the current element being processed in the
 parent stream, but we guarantee that the tap finishes and all exceptions
 from it are drained before the parent stream stops.</p><p>Compare with <code>tap</code>.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:39" id="g:39"><h1>Windowed Classification</h1></a><a href="#g:40" id="g:40"><h2>Tumbling Windows</h2></a><div class="top"><p class="src"><a id="v:classifySessionsBy" class="def">classifySessionsBy</a> <a href="src/Streamly.Internal.Prelude.html#classifySessionsBy" class="link">Source</a> <a href="#v:classifySessionsBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>timer tick in seconds</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session timeout</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>reset the timeout when an event is received</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, timestamp, close event, data</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>classifySessionsBy tick timeout reset f stream</code> groups together all input
 stream elements that belong to the same session. <code>timeout</code> is the maximum
 lifetime of a session in seconds. All elements belonging to a session are
 purged after this duration.  If &quot;reset&quot; is <code>Ture</code> then the timeout is reset
 after every event received in the session. Session duration is measured
 using the timestamp of the first element seen for that session.  To detect
 session timeouts, a monotonic event time clock is maintained using the
 timestamps seen in the inputs and a timer with a tick duration specified by
 <code>tick</code>.</p><p><code>session key</code> is a key that uniquely identifies the session for the given
 element, <code>timestamp</code> characterizes the time when the input element was
 generated, this is an absolute time measured from some <code>Epoch</code>. <code>session
 close</code> is a boolean indicating whether this element marks the closing of the
 session. When an input element with <code>session close</code> set to <code>True</code> is seen
 the session is purged immediately.</p><p>All the input elements belonging to a session are collected using the fold
 <code>f</code>.  The session key and the fold result are emitted in the output stream
 when the session is purged either via the session close event or via the
 session liftime timeout.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:classifySessionsOf" class="def">classifySessionsOf</a> <a href="src/Streamly.Internal.Prelude.html#classifySessionsOf" class="link">Source</a> <a href="#v:classifySessionsOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>time window size</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to window events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>window key, data, close flag, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Split the stream into fixed size time windows of specified interval in
 seconds. Within each such window, fold the elements in buckets identified by
 the keys. A particular bucket fold can be terminated early if a closing flag
 is encountered in an element for that key. Once a fold is terminated the key
 and value for that bucket are emitted in the output stream.</p><p>Session <code>timestamp</code> in the input stream is an absolute time from some epoch,
 characterizing the time when the input element was generated.  To detect
 session window end, a monotonic event time clock is maintained synced with
 the timestamps with a clock resolution of 1 second.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:41" id="g:41"><h2>Keep Alive Windows</h2></a><div class="top"><p class="src"><a id="v:classifyKeepAliveSessions" class="def">classifyKeepAliveSessions</a> <a href="src/Streamly.Internal.Prelude.html#classifyKeepAliveSessions" class="link">Source</a> <a href="#v:classifyKeepAliveSessions" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session inactive timeout</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session payload data</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, close flag, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:classifySessionsOf" title="Streamly.Internal.Prelude">classifySessionsOf</a></code> but the session is kept alive if an event is
 received within the session window. The session times out and gets closed
 only if no event is received within the specified session window size.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:42" id="g:42"><h2>Sliding Window Buffers</h2></a><a href="#g:43" id="g:43"><h2>Containers of Streams</h2></a><div class="top"><p class="src"><a id="v:foldWith" class="def">foldWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a <a href="src/Streamly.Streams.Prelude.html#foldWith" class="link">Source</a> <a href="#v:foldWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:fold" title="Data.Foldable">fold</a></code> that allows you to fold a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>
 container of streams using the specified stream sum operation.</p><pre>foldWith <code>async</code> $ map return [1..3]</pre><p>Equivalent to:</p><pre>foldWith f = S.foldMapWith f id
</pre><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:foldMapWith" class="def">foldMapWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b <a href="src/Streamly.Streams.Prelude.html#foldMapWith" class="link">Source</a> <a href="#v:foldMapWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> that allows you to map a monadic streaming action
 on a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> container and then fold it using the specified stream merge
 operation.</p><pre>foldMapWith <code>async</code> return [1..3]</pre><p>Equivalent to:</p><pre>foldMapWith f g xs = S.concatMapWith f g (S.fromFoldable xs)
</pre><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:forEachWith" class="def">forEachWith</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b <a href="src/Streamly.Streams.Prelude.html#forEachWith" class="link">Source</a> <a href="#v:forEachWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Prelude.html#v:foldMapWith" title="Streamly.Internal.Prelude">foldMapWith</a></code> but with the last two arguments reversed i.e. the
 monadic streaming function is the last argument.</p><p>Equivalent to:</p><pre>forEachWith = flip S.foldMapWith
</pre><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><a href="#g:44" id="g:44"><h2>Folding</h2></a><div class="top"><p class="src"><a id="v:eqBy" class="def">eqBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#eqBy" class="link">Source</a> <a href="#v:eqBy" class="selflink">#</a></p><div class="doc"><p>Compare two streams for equality using an equality function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:cmpBy" class="def">cmpBy</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Prelude.html#cmpBy" class="link">Source</a> <a href="#v:cmpBy" class="selflink">#</a></p><div class="doc"><p>Compare two streams lexicographically using a comparison function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#isPrefixOf" class="link">Source</a> <a href="#v:isPrefixOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the first stream is the same as or a prefix of the
 second. A stream is a prefix of itself.</p><pre>&gt; S.isPrefixOf (S.fromList &quot;hello&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:isSubsequenceOf" class="def">isSubsequenceOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Prelude.html#isSubsequenceOf" class="link">Source</a> <a href="#v:isSubsequenceOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if all the elements of the first stream occur, in order, in
 the second stream. The elements do not have to occur consecutively. A stream
 is a subsequence of itself.</p><pre>&gt; S.isSubsequenceOf (S.fromList &quot;hlo&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Prelude.html#stripPrefix" class="link">Source</a> <a href="#v:stripPrefix" class="selflink">#</a></p><div class="doc"><p>Drops the given prefix from a stream. Returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> if the stream does
 not start with the given prefix. Returns <code>Just nil</code> when the prefix is the
 same as the stream.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:45" id="g:45"><h1>Exceptions</h1></a><div class="top"><p class="src"><a id="v:before" class="def">before</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#before" class="link">Source</a> <a href="#v:before" class="selflink">#</a></p><div class="doc"><p>Run a side effect before the stream yields its first element.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:after" class="def">after</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#after" class="link">Source</a> <a href="#v:after" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the stream stops normally.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:bracket" class="def">bracket</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#bracket" class="link">Source</a> <a href="#v:bracket" class="selflink">#</a></p><div class="doc"><p>Run the first action before the stream starts and remember its output,
 generate a stream using the output, run the second action using the
 remembered value as an argument whenever the stream ends normally or due to
 an exception.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:onException" class="def">onException</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#onException" class="link">Source</a> <a href="#v:onException" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the stream aborts due to an exception.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:finally" class="def">finally</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#finally" class="link">Source</a> <a href="#v:finally" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the stream stops normally or aborts due to an
 exception.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:handle" class="def">handle</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#handle" class="link">Source</a> <a href="#v:handle" class="selflink">#</a></p><div class="doc"><p>When evaluating a stream if an exception occurs, stream evaluation aborts
 and the specified exception handler is run with the exception as argument.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:46" id="g:46"><h1>Generalize Inner Monad</h1></a><div class="top"><p class="src"><a id="v:hoist" class="def">hoist</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> n) =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> n a <a href="src/Streamly.Internal.Prelude.html#hoist" class="link">Source</a> <a href="#v:hoist" class="selflink">#</a></p><div class="doc"><p>Transform the inner monad of a stream using a natural transformation.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:generally" class="def">generally</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#generally" class="link">Source</a> <a href="#v:generally" class="selflink">#</a></p><div class="doc"><p>Generalize the inner monad of the stream from <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code> to any monad.</p><p><em> Internal</em></p></div></div><a href="#g:47" id="g:47"><h1>Transform Inner Monad</h1></a><div class="top"><p class="src"><a id="v:liftInner" class="def">liftInner</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> tr, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (tr m)) =&gt; t m a -&gt; t (tr m) a <a href="src/Streamly.Internal.Prelude.html#liftInner" class="link">Source</a> <a href="#v:liftInner" class="selflink">#</a></p><div class="doc"><p>Lift the inner monad of a stream using a monad transformer.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:runReaderT" class="def">runReaderT</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; s -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> s m) a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#runReaderT" class="link">Source</a> <a href="#v:runReaderT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a></code>.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:evalStateT" class="def">evalStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a <a href="src/Streamly.Internal.Prelude.html#evalStateT" class="link">Source</a> <a href="#v:evalStateT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a></code>.</p><p>This is supported only for <code><a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:usingStateT" class="def">usingStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; (<a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a <a href="src/Streamly.Internal.Prelude.html#usingStateT" class="link">Source</a> <a href="#v:usingStateT" class="selflink">#</a></p><div class="doc"><p>Run a stateful (StateT) stream transformation using a given state.</p><p>This is supported only for <code><a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:runStateT" class="def">runStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; s -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m (s, a) <a href="src/Streamly.Internal.Prelude.html#runStateT" class="link">Source</a> <a href="#v:runStateT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a></code> and emit the resulting
 state and value pair after each step.</p><p>This is supported only for <code><a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p><em> Internal</em></p></div></div><a href="#g:48" id="g:48"><h1>Diagnostics</h1></a><div class="top"><p class="src"><a id="v:inspectMode" class="def">inspectMode</a> :: <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t =&gt; t m a -&gt; t m a <a href="src/Streamly.Streams.Combinators.html#inspectMode" class="link">Source</a> <a href="#v:inspectMode" class="selflink">#</a></p><div class="doc"><p>Print debug information about an SVar when the stream ends</p></div></div><a href="#g:49" id="g:49"><h1>Deprecated</h1></a><div class="top"><p class="src"><a id="v:once" class="def">once</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Streams.StreamK.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use yieldM instead.</p></div><p>Same as yieldM</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:each" class="def">each</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a <a href="src/Streamly.Internal.Prelude.html#each" class="link">Source</a> <a href="#v:each" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use fromFoldable instead.</p></div><p>Same as <code>fromFoldable</code>.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanx" class="def">scanx</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Prelude.html#scanx" class="link">Source</a> <a href="#v:scanx" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use scanl followed by map instead.</p></div><p>Strict left scan with an extraction function. Like <code><a href="Streamly-Internal-Prelude.html#v:scanl-39-" title="Streamly.Internal.Prelude">scanl'</a></code>, but applies a
 user supplied extraction function (the third argument) at each step. This is
 designed to work with the <code>foldl</code> library. The suffix <code>x</code> is a mnemonic for
 extraction.</p><p><em>Since: 0.7.0 (Monad m constraint)</em></p><p><em>Since 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldx" class="def">foldx</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldx" class="link">Source</a> <a href="#v:foldx" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use foldl' followed by fmap instead.</p></div><p>Strict left fold with an extraction function. Like the standard strict
 left fold, but applies a user supplied extraction function (the third
 argument) to the folded value at the end. This is designed to work with the
 <code>foldl</code> library. The suffix <code>x</code> is a mnemonic for extraction.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldxM" class="def">foldxM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Prelude.html#foldxM" class="link">Source</a> <a href="#v:foldxM" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use foldlM' followed by fmap instead.</p></div><p>Like <code><a href="Streamly-Internal-Prelude.html#v:foldx" title="Streamly.Internal.Prelude">foldx</a></code>, but with a monadic step function.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Prelude.html#foldr1" class="link">Source</a> <a href="#v:foldr1" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use foldrM instead.</p></div><p>Lazy right fold for non-empty streams, using first element as the starting
 value. Returns <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#v:Nothing" title="GHC.Maybe">Nothing</a></code> if the stream is empty.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:runStream" class="def">runStream</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#runStream" class="link">Source</a> <a href="#v:runStream" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drain&quot; instead</p></div><p>Run a stream, discarding the results. By default it interprets the stream
 as <code><a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a></code>, to run other types of streams use the type adapting
 combinators for example <code>runStream . <code>asyncly</code></code>.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:runN" class="def">runN</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#runN" class="link">Source</a> <a href="#v:runN" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drainN&quot; instead</p></div><pre>runN n = runStream . take n</pre><p>Run maximum up to <code>n</code> iterations of a stream.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:runWhile" class="def">runWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Prelude.html#runWhile" class="link">Source</a> <a href="#v:runWhile" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drainWhile&quot; instead</p></div><pre>runWhile p = runStream . takeWhile p</pre><p>Run a stream as long as the predicate holds true.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromHandle" class="def">fromHandle</a> :: (<a href="Streamly.html#t:IsStream" title="Streamly">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Streamly.Internal.Prelude.html#fromHandle" class="link">Source</a> <a href="#v:fromHandle" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use Streamly.FileSystem.Handle module (see the changelog)</p></div><p>Read lines from an IO Handle into a stream of Strings.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:toHandle" class="def">toHandle</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="Streamly.html#t:SerialT" title="Streamly">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m () <a href="src/Streamly.Internal.Prelude.html#toHandle" class="link">Source</a> <a href="#v:toHandle" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use Streamly.FileSystem.Handle module (see the changelog)</p></div><pre>toHandle h = S.mapM_ $ hPutStrLn h
</pre><p>Write a stream of Strings to an IO Handle.</p><p><em>Since: 0.1.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>