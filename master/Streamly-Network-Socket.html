<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Network.Socket</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Network.Socket.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2018 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Network.Socket</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Socket Specification</a></li><li><a href="#g:2">Accept Connections</a></li><li><a href="#g:3">Read</a></li><li><a href="#g:4">Write</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides Array and stream based socket operations to connect to
 remote hosts, to receive connections from remote hosts, and to read and
 write streams and arrays of bytes to and from network sockets.</p><p>For basic socket types and operations please consult the <code>Network.Socket</code>
 module of the <a href="http://hackage.haskell.org/package/network">network</a> package.</p><h1>Examples</h1><p>To write a server, use the <code><a href="Streamly-Network-Socket.html#v:accept" title="Streamly.Network.Socket">accept</a></code> unfold to start listening for
 connections from clients.  <code><a href="Streamly-Network-Socket.html#v:accept" title="Streamly.Network.Socket">accept</a></code> supplies a stream of connected sockets.
 We can map an effectful action on this socket stream to handle the
 connections. The action would typically use socket reading and writing
 operations to communicate with the remote host. We can read/write a stream
 of bytes or a stream of chunks of bytes (<code>Array</code>).</p><p>Following is a short example of a concurrent echo server.  Please note that
 this example can be written more succinctly by using higher level operations
 from <a href="Streamly-Network-Inet-TCP.html">Streamly.Network.Inet.TCP</a> module.</p><pre>{-# LANGUAGE FlexibleContexts #-}

import Data.Function ((&amp;))
import Network.Socket
import Streamly.Internal.Network.Socket (handleWithM)
import Streamly.Network.Socket (SockSpec(..))

import Streamly
import qualified Streamly.Prelude as S
import qualified Streamly.Network.Socket as SK

main = do
    let spec = SockSpec
               { sockFamily = AF_INET
               , sockType   = Stream
               , sockProto  = defaultProtocol
               , sockOpts   = []
               }
        addr = SockAddrInet 8090 (tupleToHostAddress (0,0,0,0))
     in server spec addr

    where

    server spec addr =
          S.unfold SK.accept (maxListenQueue, spec, addr) -- SerialT IO Socket
        &amp; parallely . S.mapM (handleWithM echo)           -- SerialT IO ()
        &amp; S.drain                                         -- IO ()

    echo sk =
          S.unfold SK.readChunks sk  -- SerialT IO (Array Word8)
        &amp; S.fold (SK.writeChunks sk) -- IO ()
</pre><h1>Programmer Notes</h1><p>Read IO requests to connected stream sockets are performed in chunks of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.  Unless specified
 otherwise in the API, writes are collected into chunks of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code> before they are
 written to the socket. APIs are provided to control the chunking behavior.</p><pre>import qualified Streamly.Network.Socket as SK</pre><h1>See Also</h1><ul><li><a href="Streamly-Internal-Network-Socket.html">Streamly.Internal.Network.Socket</a></li><li><a href="http://hackage.haskell.org/package/network">network</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:SockSpec">SockSpec</a> = <a href="#v:SockSpec">SockSpec</a> {<ul class="subs"><li><a href="#v:sockFamily">sockFamily</a> :: !Family</li><li><a href="#v:sockType">sockType</a> :: !SocketType</li><li><a href="#v:sockProto">sockProto</a> :: !ProtocolNumber</li><li><a href="#v:sockOpts">sockOpts</a> :: ![(SocketOption, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)]</li></ul>}</li><li class="src short"><a href="#v:accept">accept</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="Streamly-Network-Socket.html#t:SockSpec" title="Streamly.Network.Socket">SockSpec</a>, SockAddr) Socket</li><li class="src short"><a href="#v:read">read</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:readWithBufferOf">readWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:readChunks">readChunks</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:readChunksWithBufferOf">readChunksWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:write">write</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:writeWithBufferOf">writeWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:writeChunks">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Socket Specification</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SockSpec" class="def">SockSpec</a> <a href="src/Streamly.Internal.Network.Socket.html#SockSpec" class="link">Source</a> <a href="#t:SockSpec" class="selflink">#</a></p><div class="doc"><p>Specify the socket protocol details.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SockSpec" class="def">SockSpec</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:sockFamily" class="def">sockFamily</a> :: !Family</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockType" class="def">sockType</a> :: !SocketType</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockProto" class="def">sockProto</a> :: !ProtocolNumber</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:sockOpts" class="def">sockOpts</a> :: ![(SocketOption, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)]</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><a href="#g:2" id="g:2"><h1>Accept Connections</h1></a><div class="top"><p class="src"><a id="v:accept" class="def">accept</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="Streamly-Network-Socket.html#t:SockSpec" title="Streamly.Network.Socket">SockSpec</a>, SockAddr) Socket <a href="src/Streamly.Internal.Network.Socket.html#accept" class="link">Source</a> <a href="#v:accept" class="selflink">#</a></p><div class="doc"><p>Unfold a three tuple <code>(listenQLen, spec, addr)</code> into a stream of connected
 protocol sockets corresponding to incoming connections. <code>listenQLen</code> is the
 maximum number of pending connections in the backlog. <code>spec</code> is the socket
 protocol and options specification and <code>addr</code> is the protocol address where
 the server listens for incoming connections.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Read</h1></a><div class="top"><p class="src"><a id="v:read" class="def">read</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Network.Socket.html#read" class="link">Source</a> <a href="#v:read" class="selflink">#</a></p><div class="doc"><p>Unfolds a <code>Socket</code> into a byte stream.  IO requests to the socket are
 performed in sizes of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readWithBufferOf" class="def">readWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Network.Socket.html#readWithBufferOf" class="link">Source</a> <a href="#v:readWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Unfolds the tuple <code>(bufsize, socket)</code> into a byte stream, read requests
 to the socket are performed using buffers of <code>bufsize</code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readChunks" class="def">readChunks</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m Socket (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.Network.Socket.html#readChunks" class="link">Source</a> <a href="#v:readChunks" class="selflink">#</a></p><div class="doc"><p>Unfolds a socket into a stream of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></code> arrays. Requests to the socket
 are performed using a buffer of size
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>. The
 size of arrays in the resulting stream are therefore less than or equal to
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:readChunksWithBufferOf" class="def">readChunksWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, Socket) (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.Network.Socket.html#readChunksWithBufferOf" class="link">Source</a> <a href="#v:readChunksWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Unfold the tuple <code>(bufsize, socket)</code> into a stream of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></code> arrays.
 Read requests to the socket are performed using a buffer of size <code>bufsize</code>.
 The size of an array in the resulting stream is always less than or equal to
 <code>bufsize</code>.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:4" id="g:4"><h1>Write</h1></a><div class="top"><p class="src"><a id="v:write" class="def">write</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.Network.Socket.html#write" class="link">Source</a> <a href="#v:write" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a socket. Accumulates the input in chunks of
 up to <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code> bytes before writing.</p><pre>write = <code><a href="Streamly-Network-Socket.html#v:writeWithBufferOf" title="Streamly.Network.Socket">writeWithBufferOf</a></code> <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeWithBufferOf" class="def">writeWithBufferOf</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.Network.Socket.html#writeWithBufferOf" class="link">Source</a> <a href="#v:writeWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a socket. Accumulates the input in chunks of
 specified number of bytes before writing.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeChunks" class="def">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; Socket -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) () <a href="src/Streamly.Internal.Network.Socket.html#writeChunks" class="link">Source</a> <a href="#v:writeChunks" class="selflink">#</a></p><div class="doc"><p>Write a stream of arrays to a socket.  Each array in the stream is written
 to the socket as a separate IO request.</p><p><em>Since: 0.7.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>