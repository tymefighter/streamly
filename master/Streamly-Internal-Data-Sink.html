<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Sink</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Sink.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Sink</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Upgrading</a></li><li><a href="#g:2">Composing Sinks</a><ul><li><a href="#g:3">Distribute</a></li><li><a href="#g:4">Demultiplex</a></li><li><a href="#g:5">Unzip</a></li></ul></li><li><a href="#g:6">Input Transformation</a></li><li><a href="#g:7">Sinks</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> type is a just a special case of <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> and we can do without
 it. However, in some cases <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> is a simpler type and may provide better
 performance than <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> because it does not maintain any state. Folds can
 be used for both pure and monadic computations. Sinks are not applicable to
 pure computations.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Sink">Sink</a> m a = <a href="#v:Sink">Sink</a> (a -&gt; m ())</li><li class="src short"><a href="#v:toFold">toFold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a ()</li><li class="src short"><a href="#v:tee">tee</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:distribute">distribute</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; [<a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a] -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:demux">demux</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m (a, k)</li><li class="src short"><a href="#v:unzipM">unzipM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m c -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:unzip">unzip</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; (b, c)) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m c -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:lmap">lmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:lmapM">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:lfilter">lfilter</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:lfilterM">lfilterM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:drain">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li><li class="src short"><a href="#v:drainM">drainM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Sink" class="def">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.Types.html#Sink" class="link">Source</a> <a href="#t:Sink" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> is a special type of <code>Fold</code> that does not accumulate any value,
 but runs only effects. A <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> has no state to maintain therefore can be a
 bit more efficient than a <code>Fold</code> with '()' as the state, especially when
 <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code>s are composed with other operations. A Sink can be upgraded to a
 <code>Fold</code>, but a <code>Fold</code> cannot be converted into a Sink.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Sink" class="def">Sink</a> (a -&gt; m ())</td><td class="doc empty">&nbsp;</td></tr></table></div></div><a href="#g:1" id="g:1"><h1>Upgrading</h1></a><div class="top"><p class="src"><a id="v:toFold" class="def">toFold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a () <a href="src/Streamly.Internal.Data.Sink.html#toFold" class="link">Source</a> <a href="#v:toFold" class="selflink">#</a></p><div class="doc"><p>Convert a <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> to a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. When you want to compose sinks and folds
 together, upgrade a sink to a fold before composing.</p></div></div><a href="#g:2" id="g:2"><h1>Composing Sinks</h1></a><a href="#g:3" id="g:3"><h2>Distribute</h2></a><div class="top"><p class="src"><a id="v:tee" class="def">tee</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#tee" class="link">Source</a> <a href="#v:tee" class="selflink">#</a></p><div class="doc"><p>Distribute one copy each of the input to both the sinks.</p><pre>                |-------Sink m a
---stream m a---|
                |-------Sink m a
</pre><pre>&gt; let pr x = Sink.drainM (putStrLn . ((x ++ &quot; &quot;) ++) . show)
&gt; sink (Sink.tee (pr &quot;L&quot;) (pr &quot;R&quot;)) (S.enumerateFromTo 1 2)
L 1
R 1
L 2
R 2
</pre></div></div><div class="top"><p class="src"><a id="v:distribute" class="def">distribute</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; [<a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a] -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#distribute" class="link">Source</a> <a href="#v:distribute" class="selflink">#</a></p><div class="doc"><p>Distribute copies of the input to all the sinks in a container.</p><pre>                |-------Sink m a
---stream m a---|
                |-------Sink m a
                |
                      ...
</pre><pre>&gt; let pr x = Sink.drainM (putStrLn . ((x ++ &quot; &quot;) ++) . show)
&gt; sink (Sink.distribute [(pr &quot;L&quot;), (pr &quot;R&quot;)]) (S.enumerateFromTo 1 2)
L 1
R 1
L 2
R 2
</pre><p>This is the consumer side dual of the producer side <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:sequence_" title="Data.Foldable">sequence_</a></code> operation.</p></div></div><a href="#g:4" id="g:4"><h2>Demultiplex</h2></a><div class="top"><p class="src"><a id="v:demux" class="def">demux</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k (<a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m (a, k) <a href="src/Streamly.Internal.Data.Sink.html#demux" class="link">Source</a> <a href="#v:demux" class="selflink">#</a></p><div class="doc"><p>Demultiplex to multiple consumers without collecting the results. Useful
 to run different effectful computations depending on the value of the stream
 elements, for example handling network packets of different types using
 different handlers.</p><pre>
                            |-------Sink m a
-----stream m a-----Map-----|
                            |-------Sink m a
                            |
                                      ...
</pre><pre>&gt; let pr x = Sink.drainM (putStrLn . ((x ++ &quot; &quot;) ++) . show)
&gt; let table = Data.Map.fromList [(1, pr &quot;One&quot;), (2, pr &quot;Two&quot;)]
  in Sink.sink (Sink.demux id table) (S.enumerateFromTo 1 100)
One 1
Two 2
</pre></div></div><a href="#g:5" id="g:5"><h2>Unzip</h2></a><div class="top"><p class="src"><a id="v:unzipM" class="def">unzipM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m (b, c)) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m c -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#unzipM" class="link">Source</a> <a href="#v:unzipM" class="selflink">#</a></p><div class="doc"><p>Split elements in the input stream into two parts using a monadic unzip
 function, direct each part to a different sink.</p><pre>
                          |-------Sink m b
-----Stream m a----(b,c)--|
                          |-------Sink m c
</pre><pre>&gt; let pr x = Sink.drainM (putStrLn . ((x ++ &quot; &quot;) ++) . show)
  in Sink.sink (Sink.unzip return (pr &quot;L&quot;) (pr &quot;R&quot;)) (S.yield (1,2))
L 1
R 2
</pre></div></div><div class="top"><p class="src"><a id="v:unzip" class="def">unzip</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; (b, c)) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m c -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#unzip" class="link">Source</a> <a href="#v:unzip" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Sink.html#v:unzipM" title="Streamly.Internal.Data.Sink">unzipM</a></code> but with a pure unzip function.</p></div></div><a href="#g:6" id="g:6"><h1>Input Transformation</h1></a><div class="doc"><p>These are contravariant operations i.e. they apply on the input of the
 <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code>, for this reason they are prefixed with <code>l</code> for <code>left</code>.</p></div><div class="top"><p class="src"><a id="v:lmap" class="def">lmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#lmap" class="link">Source</a> <a href="#v:lmap" class="selflink">#</a></p><div class="doc"><p>Map a pure function on the input of a <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:lmapM" class="def">lmapM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m b -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#lmapM" class="link">Source</a> <a href="#v:lmapM" class="selflink">#</a></p><div class="doc"><p>Map a monadic function on the input of a <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:lfilter" class="def">lfilter</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#lfilter" class="link">Source</a> <a href="#v:lfilter" class="selflink">#</a></p><div class="doc"><p>Filter the input of a <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> using a pure predicate function.</p></div></div><div class="top"><p class="src"><a id="v:lfilterM" class="def">lfilterM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#lfilterM" class="link">Source</a> <a href="#v:lfilterM" class="selflink">#</a></p><div class="doc"><p>Filter the input of a <code><a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a></code> using a monadic predicate function.</p></div></div><a href="#g:7" id="g:7"><h1>Sinks</h1></a><div class="top"><p class="src"><a id="v:drain" class="def">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#drain" class="link">Source</a> <a href="#v:drain" class="selflink">#</a></p><div class="doc"><p>Drain all input, running the effects and discarding the results.</p></div></div><div class="top"><p class="src"><a id="v:drainM" class="def">drainM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Sink.html#t:Sink" title="Streamly.Internal.Data.Sink">Sink</a> m a <a href="src/Streamly.Internal.Data.Sink.html#drainM" class="link">Source</a> <a href="#v:drainM" class="selflink">#</a></p><div class="doc"><pre>drainM f = lmapM f drain</pre><p>Drain all input after passing it through a monadic function.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>