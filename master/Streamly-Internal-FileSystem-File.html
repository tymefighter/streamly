<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.FileSystem.File</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.FileSystem.File.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Harendra Kumar</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.FileSystem.File</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Streaming IO</a><ul><li><a href="#g:2">File IO Using Handle</a></li><li><a href="#g:3">Read From File</a></li><li><a href="#g:4">Write To File</a></li><li><a href="#g:5">Append To File</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Read and write streams and arrays to and from files specified by their paths
 in the file system. Unlike the handle based APIs which can have a read/write
 session consisting of multiple reads and writes to the handle, these APIs
 are one shot read or write APIs. These APIs open the file handle, perform
 the requested operation and close the handle. Thease are safer compared to
 the handle based APIs as there is no possibility of a file descriptor
 leakage.</p><pre>import qualified Streamly.Internal.FileSystem.File as File</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:withFile">withFile</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IOMode" title="System.IO">IOMode</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:read">read</a> :: (MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:toBytes">toBytes</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></li><li class="src short"><a href="#v:toChunksWithBufferOf">toChunksWithBufferOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:toChunks">toChunks</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</li><li class="src short"><a href="#v:write">write</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:writeWithBufferOf">writeWithBufferOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> ()</li><li class="src short"><a href="#v:fromBytes">fromBytes</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m ()</li><li class="src short"><a href="#v:fromBytesWithBufferOf">fromBytesWithBufferOf</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m ()</li><li class="src short"><a href="#v:writeArray">writeArray</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:writeChunks">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) ()</li><li class="src short"><a href="#v:fromChunks">fromChunks</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) -&gt; m ()</li><li class="src short"><a href="#v:append">append</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m ()</li><li class="src short"><a href="#v:appendWithBufferOf">appendWithBufferOf</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m ()</li><li class="src short"><a href="#v:appendArray">appendArray</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:appendChunks">appendChunks</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) -&gt; m ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Streaming IO</h1></a><div class="doc"><p>Stream data to or from a file or device sequentially.  When reading,
 the stream is lazy and generated on-demand as the consumer consumes it.
 Read IO requests to the IO device are performed in chunks limited to a
 maximum size of 32KiB, this is referred to as <code>defaultChunkSize</code> in the
 documentation. One IO request may or may not read the full
 chunk. If the whole stream is not consumed, it is possible that we may
 read slightly more from the IO device than what the consumer needed.
 Unless specified otherwise in the API, writes are collected into chunks
 of <code>defaultChunkSize</code> before they are written to the IO device.</p></div><a href="#g:2" id="g:2"><h2>File IO Using Handle</h2></a><div class="top"><p class="src"><a id="v:withFile" class="def">withFile</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IOMode" title="System.IO">IOMode</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.FileSystem.File.html#withFile" class="link">Source</a> <a href="#v:withFile" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Streamly-Internal-FileSystem-File.html#v:withFile" title="Streamly.Internal.FileSystem.File">withFile</a></code> name mode act</code> opens a file using <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle-FD.html#v:openFile" title="GHC.IO.Handle.FD">openFile</a></code> and passes
 the resulting handle to the computation <code>act</code>.  The handle will be
 closed on exit from <code><a href="Streamly-Internal-FileSystem-File.html#v:withFile" title="Streamly.Internal.FileSystem.File">withFile</a></code>, whether by normal termination or by
 raising an exception.  If closing the handle raises an exception, then
 this exception will be raised by <code><a href="Streamly-Internal-FileSystem-File.html#v:withFile" title="Streamly.Internal.FileSystem.File">withFile</a></code> rather than any exception
 raised by <code>act</code>.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h2>Read From File</h2></a><div class="top"><p class="src"><a id="v:read" class="def">read</a> :: (MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.FileSystem.File.html#read" class="link">Source</a> <a href="#v:read" class="selflink">#</a></p><div class="doc"><p>Unfolds a file path into a byte stream. IO requests to the device are
 performed in sizes of
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:toBytes" class="def">toBytes</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.FileSystem.File.html#toBytes" class="link">Source</a> <a href="#v:toBytes" class="selflink">#</a></p><div class="doc"><p>Generate a stream of bytes from a file specified by path. The stream ends
 when EOF is encountered. File is locked using multiple reader and single
 writer locking mode.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toChunksWithBufferOf" class="def">toChunksWithBufferOf</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.FileSystem.File.html#toChunksWithBufferOf" class="link">Source</a> <a href="#v:toChunksWithBufferOf" class="selflink">#</a></p><div class="doc"><p><code>toChunksWithBufferOf size file</code> reads a stream of arrays from file <code>file</code>.
 The maximum size of a single array is specified by <code>size</code>. The actual size
 read may be less than or equal to <code>size</code>.</p></div></div><div class="top"><p class="src"><a id="v:toChunks" class="def">toChunks</a> :: (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.StreamK.Type">IsStream</a> t, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; t m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) <a href="src/Streamly.Internal.FileSystem.File.html#toChunks" class="link">Source</a> <a href="#v:toChunks" class="selflink">#</a></p><div class="doc"><p><code>toChunks file</code> reads a stream of arrays from file <code>file</code>.
 The maximum size of a single array is limited to <code>defaultChunkSize</code>. The
 actual size read may be less than <code>defaultChunkSize</code>.</p><pre>toChunks = toChunksWithBufferOf defaultChunkSize</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:4" id="g:4"><h2>Write To File</h2></a><div class="top"><p class="src"><a id="v:write" class="def">write</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.FileSystem.File.html#write" class="link">Source</a> <a href="#v:write" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a file. Accumulates the input in chunks of up to
 <code><a href="Streamly-Internal-Memory-Array-Types.html#v:defaultChunkSize" title="Streamly.Internal.Memory.Array.Types">defaultChunkSize</a></code> before writing to
 the IO device.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:writeWithBufferOf" class="def">writeWithBufferOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> () <a href="src/Streamly.Internal.FileSystem.File.html#writeWithBufferOf" class="link">Source</a> <a href="#v:writeWithBufferOf" class="selflink">#</a></p><div class="doc"><p><code>writeWithBufferOf chunkSize handle</code> writes the input stream to <code>handle</code>.
 Bytes in the input stream are collected into a buffer until we have a chunk
 of size <code>chunkSize</code> and then written to the IO device.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromBytes" class="def">fromBytes</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#fromBytes" class="link">Source</a> <a href="#v:fromBytes" class="selflink">#</a></p><div class="doc"><p>Write a byte stream to a file. Combines the bytes in chunks of size
 up to <code><a href="A.html#v:defaultChunkSize" title="A">defaultChunkSize</a></code> before writing. If the file exists it is
 truncated to zero size before writing. If the file does not exist it is
 created. File is locked using single writer locking mode.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromBytesWithBufferOf" class="def">fromBytesWithBufferOf</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#fromBytesWithBufferOf" class="link">Source</a> <a href="#v:fromBytesWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-FileSystem-File.html#v:write" title="Streamly.Internal.FileSystem.File">write</a></code> but provides control over the write buffer. Output will
 be written to the IO device as soon as we collect the specified number of
 input elements.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeArray" class="def">writeArray</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Streamly.Internal.FileSystem.File.html#writeArray" class="link">Source</a> <a href="#v:writeArray" class="selflink">#</a></p><div class="doc"><p>Write an array to a file. Overwrites the file if it exists.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:writeChunks" class="def">writeChunks</a> :: (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) () <a href="src/Streamly.Internal.FileSystem.File.html#writeChunks" class="link">Source</a> <a href="#v:writeChunks" class="selflink">#</a></p><div class="doc"><p>Write a stream of chunks to a handle. Each chunk in the stream is written
 to the device as a separate IO request.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromChunks" class="def">fromChunks</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#fromChunks" class="link">Source</a> <a href="#v:fromChunks" class="selflink">#</a></p><div class="doc"><p>Write a stream of arrays to a file. Overwrites the file if it exists.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:5" id="g:5"><h2>Append To File</h2></a><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#append" class="link">Source</a> <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>Append a byte stream to a file. Combines the bytes in chunks of size up to
 <code><a href="A.html#v:defaultChunkSize" title="A">defaultChunkSize</a></code> before writing.  If the file exists then the new data
 is appended to the file.  If the file does not exist it is created. File is
 locked using single writer locking mode.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:appendWithBufferOf" class="def">appendWithBufferOf</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#appendWithBufferOf" class="link">Source</a> <a href="#v:appendWithBufferOf" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-FileSystem-File.html#v:append" title="Streamly.Internal.FileSystem.File">append</a></code> but provides control over the write buffer. Output will
 be written to the IO device as soon as we collect the specified number of
 input elements.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:appendArray" class="def">appendArray</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Streamly.Internal.FileSystem.File.html#appendArray" class="link">Source</a> <a href="#v:appendArray" class="selflink">#</a></p><div class="doc"><p>append an array to a file.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:appendChunks" class="def">appendChunks</a> :: (<a href="Streamly-Internal-Data-SVar.html#t:MonadAsync" title="Streamly.Internal.Data.SVar">MonadAsync</a> m, MonadCatch m, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="Streamly-Internal-Memory-Array-Types.html#t:Array" title="Streamly.Internal.Memory.Array.Types">Array</a> a) -&gt; m () <a href="src/Streamly.Internal.FileSystem.File.html#appendChunks" class="link">Source</a> <a href="#v:appendChunks" class="selflink">#</a></p><div class="doc"><p>Append a stream of arrays to a file.</p><p><em>Since: 0.7.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>