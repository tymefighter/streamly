<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Parser.Types</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.Types.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser.Types</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Streaming and backtracking parsers.</p><p>The <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> type or a parsing fold is a generalization of the <code>Fold</code> type.
 The <code>Fold</code> type always succeeds on each input. Therefore it does not need to
 buffer the input. In contrast, a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> may fail and backtrack to replay
 the input again to explore another branch of the parser. Therefore, it needs
 to buffer the input.</p><p>The <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> type is an extension of the <code>Fold</code> type.  The <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> functor
 for the <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> type has been specifically designed for stream parsing
 applications, assuming the input to be a seuqentially read stream and
 potentially buffering a contiguous segment of the stream based on the
 parser's need.</p><p>To provide richer communication with the input stream, the <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> functor of
 a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> provides more powerful commands to manipulate the input stream
 after each step invocation. It allows the fold driver to:</p><ol><li>Buffer the input until explicitly asked to drop the input</li><li>Drop the input stream beyond a &quot;point of no return&quot; in the history
 because the input till that point has been consumed irrevocably.</li><li>Go back in the buffered stream upto the point of no return.</li></ol><p>Based on application requirements it should be possible to design even a
 richer interface to manipulate the input stream/buffer. For example, we
 could randomly seek into the stream in the forward or reverse directions or
 we can even seek to the end or from the end or seek from the beginning.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s<ul class="subs"><li>= <a href="#v:Yield">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Skip">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Stop">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> m a b = <a href="#v:Parser">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s)) (m s) (s -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b))</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s <a href="src/Streamly.Internal.Data.Parser.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>The return type of a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> step.</p><p>A parser is driven by a parse driver one step at a time, at any time the
 driver may <code>extract</code> the result of the parser. The parser may ask the driver
 to backtrack at any point, therefore, the driver holds the input up to a
 point of no return in a backtracking buffer.  The buffer grows or shrinks
 based on the return values of the parser step execution.</p><p>When a parser step is executed it generates a new state of the parse result
 along with a command to the driver. The command tells the driver whether to
 keep the input stream for backtracking or drop it, and how much to keep. The
 constructors of <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> represent the commands to the driver.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Yield" class="def">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Yield offset state</code> indicates that the parser has yielded a new
 result which is a point of no return. The result can be extracted
 using <code>extract</code>. The driver drops the buffer except <code>offset</code> elements
 before the current position in stream. The rule is that if a parser
 has yielded at least once it cannot return a failure result.</p></td></tr><tr><td class="src"><a id="v:Skip" class="def">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Skip offset state</code> indicates that the parser has consumed the current
 input but no new result has been generated. A new <code>state</code> is generated.
 However, if we use <code>extract</code> on <code>state</code> it will generate a result from
 the previous <code>Yield</code>.  When <code>offset</code> is non-zero it is a backward offset
 from the current position in the stream from which the driver will feed
 the next input to the parser. The offset cannot be beyond the latest
 point of no return created by <code>Yield</code>.</p></td></tr><tr><td class="src"><a id="v:Stop" class="def">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Stop offset state</code> asks the driver to stop driving the parser because
 it has reached a fixed point and further input will not change the
 result.  <code>offset</code> is the count of unused elements which includes the
 element on which <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Stop" title="Streamly.Internal.Data.Parser.Types">Stop</a></code> occurred.  Once a fold stops, driving it further
 may produce undefined behavior.</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parser" class="def">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>A parsing fold is represented as <code>Parser step initial extract</code>. Before we
 drive a parser we call the <code>initial</code> action to retrieve the initial state of
 the fold. The driver invokes <code>step</code> with the state returned by the previous
 step and the next input element. It results into a new state and a command
 to the driver represented by <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> type. At any point of time the driver
 can call <code>extract</code> to inspect the result of the fold. It may result in an
 error or an output value.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Parser" class="def">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s)) (m s) (s -&gt; m (<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:Parser" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-110" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Maps a function over the output of the fold.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Applicative:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-179" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> form of <code><a href="Streamly-Internal-Data-Parser-Types.html#v:splitWith" title="Streamly.Internal.Data.Parser.Types">splitWith</a></code>.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Types.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Apply two parsers sequentially to an input stream. The input is provided
 to the first parser, when it is done the remaining input is provided to the
 second parser. If both the parsers succeed there outputs are combined using
 the supplied function. The operation fails if any of the parsers fail.</p><p>This undoes an &quot;append&quot; of two streams, it splits the streams.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>