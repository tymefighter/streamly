<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Parser.Tee</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.Tee.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-parsers10: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser.Tee</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Parallel parsers. Distributing the input to multiple parsers at the same
 time.</p><p>For simplicity, we are using code where a particular state is unreachable
 but it is not prevented by types.  Somehow uni-pattern match using &quot;let&quot;
 produces better optimized code compared to using <code>case</code> match and using
 explicit error messages in unreachable cases.</p><p>There seem to be no way to silence individual warnings so we use a global
 incomplete uni-pattern match warning suppression option for the file.
 Disabling the warning for other code as well  has the potential to mask off
 some legit warnings, therefore, we have segregated only the code that uses
 uni-pattern matches in this module.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c</li><li class="src short"><a href="#v:shortest">shortest</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a</li><li class="src short"><a href="#v:longest">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith f p1 p2</code> distributes its input to both <code>p1</code> and <code>p2</code> until both
 of them succeed or fail and combines their output using <code>f</code>. The parser
 succeeds if both the parsers succeed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser-Tee.html#v:teeWith" title="Streamly.Internal.Data.Parser.Tee">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever the first parser ends.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser-Tee.html#v:teeWith" title="Streamly.Internal.Data.Parser.Tee">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever any of the parsers ends or fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.Tee.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 parse.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.Tee.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 parse.</p><p><em>Internal</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>