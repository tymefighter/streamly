<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Parser</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-parsers10: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Accumulators</a></li><li><a href="#g:2">Element parsers</a></li><li><a href="#g:3">Sequence parsers</a></li><li><a href="#g:4">Binary Combinators</a><ul><li><a href="#g:5">Sequential Applicative</a></li><li><a href="#g:6">Parallel Applicatives</a></li><li><a href="#g:7">Sequential Interleaving</a></li><li><a href="#g:8">Parallel Alternatives</a></li></ul></li><li><a href="#g:9">N-ary Combinators</a><ul><li><a href="#g:10">Sequential Collection</a></li><li><a href="#g:11">Sequential Repetition</a></li><li><a href="#g:12">Collection of Alternatives</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast streaming parsers.</p><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> and <code>Alternative</code> type class based combinators from the
 <a href="http://hackage.haskell.org/package/parser-combinators">parser-combinators</a>
 package can also be used with the <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type. However, there are two
 important differences between <code>parser-combinators</code> and the equivalent ones
 provided in this module in terms of performance:</p><p>1) <code>parser-combinators</code> use plain Haskell lists to collect the results, in a
 strict Monad like IO, the results are necessarily buffered before they can
 be consumed.  This may not perform optimally in streaming applications
 processing large amounts of data.  Equivalent combinators in this module can
 consume the results of parsing using a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>, thus providing a scalability
 and a generic consumer.</p><p>2) Several combinators in this module can be many times faster because of
 stream fusion. For example, <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> combinator
 in this module is much faster than the <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code> combinator
 of <code>Alternative</code> type class.</p><p>Failing parsers in this module throw the <code><a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a></code> exception.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> m a b = <a href="#v:Parser">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b)) (m s) (s -&gt; m b)</li><li class="src short"><a href="#v:fromFold">fromFold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:any">any</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:yield">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:die">die</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:dieM">dieM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:peek">peek</a> :: MonadThrow m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:eof">eof</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:satisfy">satisfy</a> :: MonadThrow m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:take">take</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeEQ">takeEQ</a> :: MonadThrow m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeGE">takeGE</a> :: MonadThrow m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:lookAhead">lookAhead</a> :: MonadThrow m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile1">takeWhile1</a> :: MonadThrow m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepBy">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepByMax">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceEndWith">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceBeginWith">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:wordBy">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:groupBy">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:eqBy">eqBy</a> :: MonadThrow m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:deintercalate">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z)</li><li class="src short"><a href="#v:shortest">shortest</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:longest">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:sequence">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:count">count</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:countBetween">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:many">many</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:some">some</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyTill">manyTill</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:choice">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parser" class="def">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>A parser is a fold that can fail and is represented as <code>Parser step
 initial extract</code>. Before we drive a parser we call the <code>initial</code> action to
 retrieve the initial state of the fold. The parser driver invokes <code>step</code>
 with the state returned by the previous step and the next input element. It
 results into a new state and a command to the driver represented by <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code>
 type. The driver keeps invoking the step function until it stops or fails.
 At any point of time the driver can call <code>extract</code> to inspect the result of
 the fold. It may result in an error or an output value.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Parser" class="def">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b)) (m s) (s -&gt; m b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:Parser" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Monad:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-585" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Monad composition can be used for lookbehind parsers, we can make the
 future parses depend on the previously parsed values.</p><p>If we have to parse &quot;a9&quot; or &quot;9a&quot; but not &quot;99&quot; or &quot;aa&quot; we can use the
 following parser:</p><pre>backtracking :: MonadCatch m =&gt; PR.Parser m Char String
backtracking =
    sequence [PR.satisfy isDigit, PR.satisfy isAlpha]
    <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>
    sequence [PR.satisfy isAlpha, PR.satisfy isDigit]
</pre><p>We know that if the first parse resulted in a digit at the first place then
 the second parse is going to fail.  However, we waste that information and
 parse the first character again in the second parse only to know that it is
 not an alphabetic char.  By using lookbehind in a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> composition we can
 avoid redundant work:</p><pre>data DigitOrAlpha = Digit Char | Alpha Char

lookbehind :: MonadCatch m =&gt; PR.Parser m Char String
lookbehind = do
    x1 &lt;-    Digit <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isDigit
         <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> Alpha <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isAlpha

    -- Note: the parse depends on what we parsed already
    x2 &lt;- case x1 of
        Digit _ -&gt; PR.satisfy isAlpha
        Alpha _ -&gt; PR.satisfy isDigit

    return $ case x1 of
        Digit x -&gt; [x,x2]
        Alpha x -&gt; [x,x2]
</pre></td></tr><tr><td colspan="2"><details id="i:id:Parser:Monad:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; (a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:return" class="selflink">#</a></p><p class="src"><a href="#v:fail">fail</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:fail" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-216" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parser:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Applicative:3"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-320" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> form of <code><a href="Streamly-Internal-Data-Parser.html#v:splitWith" title="Streamly.Internal.Data.Parser">splitWith</a></code>.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Alternative:4"></span> MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-527" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> instance using <code><a href="Streamly-Internal-Data-Parser-Types.html#v:alt" title="Streamly.Internal.Data.Parser.Types">alt</a></code>.</p><p>Note: The implementation of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> is not lazy in the second
 argument. The following code will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) &lt;|&gt; undefined) $ S.fromList [1..10]
</code></strong></pre></td></tr><tr><td colspan="2"><details id="i:id:Parser:Alternative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:MonadPlus:5"></span> MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-630" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mzero" title="Control.Monad">mzero</a></code> is same as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>, it aborts the parser. <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mplus" title="Control.Monad">mplus</a></code> is same as
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>, it selects the first succeeding parser.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parser:MonadPlus:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:1" id="g:1"><h1>Accumulators</h1></a><div class="top"><p class="src"><a id="v:fromFold" class="def">fromFold</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#fromFold" class="link">Source</a> <a href="#v:fromFold" class="selflink">#</a></p><div class="doc"><p>The resulting parse never terminates and never errors out.</p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.any (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; Right True
</pre></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.all (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; Right False
</pre></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A parser that always yields a pure value without consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A parser that always yields the result of an effectful action without
 consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:die" class="def">die</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#die" class="link">Source</a> <a href="#v:die" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an error message without consuming
 any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dieM" class="def">dieM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#dieM" class="link">Source</a> <a href="#v:dieM" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an effectful error message and without
 consuming any input.</p><p><em>Internal</em></p></div></div><a href="#g:2" id="g:2"><h1>Element parsers</h1></a><div class="top"><p class="src"><a id="v:peek" class="def">peek</a> :: MonadThrow m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#peek" class="link">Source</a> <a href="#v:peek" class="selflink">#</a></p><div class="doc"><p>Peek the head element of a stream, without consuming it. Fails if it
 encounters end of input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.peek &lt;*&gt; PR.satisfy (&gt; 0)) $ S.fromList [1]
</code></strong>(1,1)
</pre><pre>peek = lookAhead (satisfy True)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:eof" class="def">eof</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eof" class="link">Source</a> <a href="#v:eof" class="selflink">#</a></p><div class="doc"><p>Succeeds if we are at the end of input, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.satisfy (&gt; 0) &lt;*&gt; PR.eof) $ S.fromList [1]
</code></strong>&gt; (1,())
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:satisfy" class="def">satisfy</a> :: MonadThrow m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#satisfy" class="link">Source</a> <a href="#v:satisfy" class="selflink">#</a></p><div class="doc"><p>Returns the next element if it passes the predicate, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (== 1)) $ S.fromList [1,0,1]
</code></strong>&gt; 1
</pre><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Sequence parsers</h1></a><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold.</p><p>Stops after <code>n</code> elements.
 Never fails.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.take 1 FL.toList) $ S.fromList [1]
</code></strong>[1]
</pre><pre>S.chunksOf n f = S.splitParse (FL.take n f)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeEQ" class="def">takeEQ</a> :: MonadThrow m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeEQ" class="link">Source</a> <a href="#v:takeEQ" class="selflink">#</a></p><div class="doc"><p>Stops after taking exactly <code>n</code> input elements.</p><ul><li>Stops - after <code>n</code> elements.</li><li>Fails - if the stream ends before it can collect <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeEQ 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeEQ: Expecting exactly 4 elements, got 3&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeGE" class="def">takeGE</a> :: MonadThrow m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeGE" class="link">Source</a> <a href="#v:takeGE" class="selflink">#</a></p><div class="doc"><p>Take at least <code>n</code> input elements, but can collect more.</p><ul><li>Stops - never.</li><li>Fails - if the stream end before producing <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeGE: Expecting at least 4 elements, got only 3&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1,0,1]
</code></strong>&gt; [1,0,1,0,1]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:lookAhead" class="def">lookAhead</a> :: MonadThrow m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#lookAhead" class="link">Source</a> <a href="#v:lookAhead" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element fails the predicate. The element
 on which the predicate fails is returned back to the input stream.</p><ul><li>Stops - when the predicate fails.</li><li>Fails - never.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeWhile (== 0) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [0,0]
</pre><p>We can implement a <code>breakOn</code> using <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code>:</p><pre>breakOn p = takeWhile (not p)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile1" class="def">takeWhile1</a> :: MonadThrow m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile1" class="link">Source</a> <a href="#v:takeWhile1" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code> but takes at least one element otherwise fails.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepBy" class="def">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepBy" class="link">Source</a> <a href="#v:sliceSepBy" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Drop the
 element on which the predicate succeeded. The succeeding element is treated
 as an infix separator which is dropped from the output.</p><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.sliceSepBy (== 1) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [0,0]
</pre><p>S.splitOn pred f = S.splitParse (PR.sliceSepBy pred f)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.splitParse (PR.sliceSepBy (== 1) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [[0,0],[0],[]]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepByMax" class="def">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepByMax" class="link">Source</a> <a href="#v:sliceSepByMax" class="selflink">#</a></p><div class="doc"><p>Split using a condition or a count whichever occurs first. This is a
 hybrid of <code>splitOn</code> and <code><a href="Streamly-Internal-Data-Parser.html#v:take" title="Streamly.Internal.Data.Parser">take</a></code>. The element on which the condition succeeds
 is dropped.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceEndWith" class="def">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceEndWith" class="link">Source</a> <a href="#v:sliceEndWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Also take
 the element on which the predicate succeeded. The succeeding element is
 treated as a suffix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><p>S.splitWithSuffix pred f = S.splitParse (PR.sliceEndWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sliceBeginWith" class="def">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceBeginWith" class="link">Source</a> <a href="#v:sliceBeginWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an elements passes the predicate, return the
 last element on which the predicate succeeded back to the input stream.  If
 the predicate succeeds on the first element itself then it is kept in the
 stream and we continue collecting. The succeeding element is treated as a
 prefix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds in non-leading position.</li><li>Fails - never.</li></ul><p>S.splitWithPrefix pred f = S.splitParse (PR.sliceBeginWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:wordBy" class="def">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#wordBy" class="link">Source</a> <a href="#v:wordBy" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but strips leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> having <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><ul><li>Stops - when it finds a word separator after a non-word element</li><li>Fails - never.</li></ul><pre>S.wordsBy pred f = S.splitParse (PR.wordBy pred f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#groupBy" class="link">Source</a> <a href="#v:groupBy" class="selflink">#</a></p><div class="doc"><p><code>groupBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, then if <code>a `cmp` b</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> <code>b</code> is also assigned to the same
 group.  If <code>a `cmp` c</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> <code>f</code> and the result of the fold is emitted
 in the output stream.</p><ul><li>Stops - when the comparison fails.</li><li>Fails - never.</li></ul><pre>S.groupsBy cmp f = S.splitParse (PR.groupBy cmp f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:eqBy" class="def">eqBy</a> :: MonadThrow m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eqBy" class="link">Source</a> <a href="#v:eqBy" class="selflink">#</a></p><div class="doc"><p>Match the given sequence of elements using the given comparison function.</p><p><em>Internal</em></p></div></div><a href="#g:4" id="g:4"><h1>Binary Combinators</h1></a><a href="#g:5" id="g:5"><h2>Sequential Applicative</h2></a><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Types.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Sequential application. Apply two parsers sequentially to an input stream.
 The input is provided to the first parser, when it is done the remaining
 input is provided to the second parser. If both the parsers succeed their
 outputs are combined using the supplied function. The operation fails if any
 of the parsers fail.</p><p>This undoes an &quot;append&quot; of two streams, it splits the streams using two
 parsers and zips the results.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) *&gt; undefined) $ S.fromList [1]
</code></strong></pre><p><em>Internal</em></p></div></div><a href="#g:6" id="g:6"><h2>Parallel Applicatives</h2></a><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith f p1 p2</code> distributes its input to both <code>p1</code> and <code>p2</code> until both
 of them succeed or fail and combines their output using <code>f</code>. The parser
 succeeds if both the parsers succeed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever the first parser ends.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Tee.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever any of the parsers ends or fails.</p><p><em>Unimplemented</em></p></div></div><a href="#g:7" id="g:7"><h2>Sequential Interleaving</h2></a><div class="top"><p class="src"><a id="v:deintercalate" class="def">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z) <a href="src/Streamly.Internal.Data.Parser.html#deintercalate" class="link">Source</a> <a href="#v:deintercalate" class="selflink">#</a></p><div class="doc"><p>Apply two parsers alternately to an input stream. The input stream is
 considered an interleaving of two patterns. The two parsers represent the
 two patterns.</p><p>This undoes a &quot;gintercalate&quot; of two streams.</p><p><em>Unimplemented</em></p></div></div><a href="#g:8" id="g:8"><h2>Parallel Alternatives</h2></a><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.Tee.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 parse.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.Tee.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 parse.</p><p><em>Internal</em></p></div></div><a href="#g:9" id="g:9"><h1>N-ary Combinators</h1></a><a href="#g:10" id="g:10"><h2>Sequential Collection</h2></a><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p><code>sequence f t</code> collects sequential parses of parsers in the container <code>t</code>
 using the fold <code>f</code>. Fails if the input ends or any of the parsers fail.</p><p><em>Unimplemented</em></p></div></div><a href="#g:11" id="g:11"><h2>Sequential Repetition</h2></a><div class="top"><p class="src"><a id="v:count" class="def">count</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#count" class="link">Source</a> <a href="#v:count" class="selflink">#</a></p><div class="doc"><p><code>count n f p</code> collects exactly <code>n</code> sequential parses of parser <code>p</code> using
 the fold <code>f</code>.  Fails if the input ends or the parser fails before <code>n</code>
 results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:countBetween" class="def">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#countBetween" class="link">Source</a> <a href="#v:countBetween" class="selflink">#</a></p><div class="doc"><p><code>countBetween m n f p</code> collects between <code>m</code> and <code>n</code> sequential parses of
 parser <code>p</code> using the fold <code>f</code>. Stop after collecting <code>n</code> results. Fails if
 the input ends or the parser fails before <code>m</code> results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more parses. Apply the parser repeatedly on the input
 stream, stop when the parser fails, accumulate zero or more parse results
 using the supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. This parser never fails, in case the first
 application of parser fails it returns an empty result.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:some" class="def">some</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#some" class="link">Source</a> <a href="#v:some" class="selflink">#</a></p><div class="doc"><p>Collect one or more parses. Apply the supplied parser repeatedly on the
 input stream and accumulate the parse results as long as the parser
 succeeds, stop when it fails.  This parser fails if not even one result is
 collected.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:some" title="Control.Applicative">some</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:manyTill" class="def">manyTill</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyTill" class="link">Source</a> <a href="#v:manyTill" class="selflink">#</a></p><div class="doc"><p><code>manyTill f collect test</code> tries the parser <code>test</code> on the input, if <code>test</code>
 fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds <code>test</code> is
 tried again and so on. The parser stops when <code>test</code> succeeds.  The output of
 <code>test</code> is discarded and the output of <code>collect</code> is accumulated by the
 supplied fold. The parser fails if <code>collect</code> fails.</p><p><em>Internal</em></p></div></div><a href="#g:12" id="g:12"><h2>Collection of Alternatives</h2></a><div class="top"><p class="src"><a id="v:choice" class="def">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#choice" class="link">Source</a> <a href="#v:choice" class="selflink">#</a></p><div class="doc"><p><code>choice parsers</code> applies the <code>parsers</code> in order and returns the first
 successful parse.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>