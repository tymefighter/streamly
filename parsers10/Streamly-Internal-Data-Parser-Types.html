<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Parser.Types</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.Types.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-parsers10: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser.Types</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Streaming and backtracking parsers.</p><p>Parsers just extend folds.  Please read the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> design notes in
 <a href="Streamly-Internal-Data-Fold-Types.html">Streamly.Internal.Data.Fold.Types</a> for background on the design.</p><h1>Parser Design</h1><p>The <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> type or a parsing fold is a generalization of the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> type.
 The <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> type <em>always</em> succeeds on each input. Therefore, it does not need
 to buffer the input. In contrast, a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> may fail and backtrack to
 replay the input again to explore another branch of the parser. Therefore,
 it needs to buffer the input. Therefore, a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> is a fold with some
 additional requirements.  To summarize, unlike a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>, a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code>:</p><ol><li>may not generate a new value of the accumulator on every input, it may
 generate a new accumulator only after consuming multiple input elements
 (e.g. takeEQ).</li><li>on success may return some unconsumed input (e.g. takeWhile)</li><li>may fail and return all input without consuming it (e.g. satisfy)</li><li>backtrack and start inspecting the past input again (e.g. alt)</li></ol><p>These use cases require buffering and replaying of input.  To facilitate
 this, the step function of the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> is augmented to return the next state
 of the fold along with a command tag using a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> functor, the tag tells
 the fold driver to manipulate the future input as the parser wishes. The
 <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> functor provides the following commands to the fold driver
 corresponding to the use cases outlined in the previous para:</p><ol><li><code><a href="Streamly-Internal-Data-Parser-Types.html#v:Skip" title="Streamly.Internal.Data.Parser.Types">Skip</a></code>: hold (buffer) the input or go back to a previous position in the stream</li><li><code><a href="Streamly-Internal-Data-Parser-Types.html#v:Yield" title="Streamly.Internal.Data.Parser.Types">Yield</a></code>, <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Stop" title="Streamly.Internal.Data.Parser.Types">Stop</a></code>: tell how much input is unconsumed</li><li><code><a href="Streamly-Internal-Data-Parser-Types.html#v:Error" title="Streamly.Internal.Data.Parser.Types">Error</a></code>: indicates that the parser has failed without a result</li></ol><h1>How a Parser Works?</h1><p>A parser is just like a fold, it keeps consuming inputs from the stream and
 accumulating them in an accumulator. The accumulator of the parser could be
 a singleton value or it could be a collection of values e.g. a list.</p><p>The parser may build a new output value from multiple input items. When it
 consumes an input item but needs more input to build a complete output item
 it uses <code>Skip 0 s</code>, yielding the intermediate state <code>s</code> and asking the
 driver to provide more input.  When the parser determines that a new output
 value is complete it can use a <code>Stop n b</code> to terminate the parser with <code>n</code>
 items of input unused and the final value of the accumulator returned as
 <code>b</code>. If at any time the parser determines that the parse has failed it can
 return <code>Error err</code>.</p><p>A parser building a collection of values (e.g. a list) can use the <code>Yield</code>
 constructor whenever a new item in the output collection is generated. If a
 parser building a collection of values has yielded at least one value then
 it considered successful and cannot fail after that. In the current
 implementation, this is not automatically enforced, there is a rule that the
 parser MUST use only <code>Stop</code> for termination after the first <code>Yield</code>, it
 cannot use <code>Error</code>. It may be possible to change the implementation so that
 this rule is not required, but there may be some performance cost to it.</p><p><code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code> and
 <code><a href="Streamly-Internal-Data-Parser.html#v:some" title="Streamly.Internal.Data.Parser">some</a></code> combinators are good examples of
 efficient implementations using all features of this representation.  It is
 possible to idiomatically build a collection of parsed items using a
 singleton parser and <code>Alternative</code> instance instead of using a
 multi-yield parser.  However, this implementation is amenable to stream
 fusion and can therefore be much faster.</p><h1>Error Handling</h1><p>When a parser's <code>step</code> function is invoked it may iterminate by either a
 <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Stop" title="Streamly.Internal.Data.Parser.Types">Stop</a></code> or an <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Error" title="Streamly.Internal.Data.Parser.Types">Error</a></code> return value. In an <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> composition an error
 return can make the composed parser backtrack and try another parser.</p><p>If the stream stops before a parser could terminate then we use the
 <code>extract</code> function of the parser to retrieve the last yielded value of the
 parser. If the parser has yielded at least one value then <code>extract</code> MUST
 return a value without throwing an error, otherwise it uses the <code><a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a></code>
 exception to throw an error.</p><p>We chose the exception throwing mechanism for <code>extract</code> instead of using an
 explicit error return via an <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> type for keeping the interface simple
 as most of the time we do not need to catch the error in intermediate
 layers. Note that we cannot use exception throwing mechanism in <code>step</code>
 function because of performance reasons. <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Error" title="Streamly.Internal.Data.Parser.Types">Error</a></code> constructor in that case
 allows loop fusion and better performance.</p><h1>Future Work</h1><p>It may make sense to move &quot;takeWhile&quot; type of parsers, which cannot fail but
 need some lookahead, to splitting folds.  This will allow such combinators
 to be accepted where we need an unfailing <a href="Fold.html">Fold</a> type.</p><p>Based on application requirements it should be possible to design even a
 richer interface to manipulate the input stream/buffer. For example, we
 could randomly seek into the stream in the forward or reverse directions or
 we can even seek to the end or from the end or seek from the beginning.</p><p>We can distribute and scan/parse a stream using both folds and parsers and
 merge the resulting streams using different merge strategies (e.g.
 interleaving or serial).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Yield">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Skip">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Stop">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</li><li>| <a href="#v:Error">Error</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> m a b = <a href="#v:Parser">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b)) (m s) (s -&gt; m b)</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:ParseError">ParseError</a> = <a href="#v:ParseError">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:yield">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c</li><li class="src short"><a href="#v:die">die</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b</li><li class="src short"><a href="#v:dieM">dieM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b</li><li class="src short"><a href="#v:splitSome">splitSome</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c</li><li class="src short"><a href="#v:splitMany">splitMany</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c</li><li class="src short"><a href="#v:alt">alt</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Parser.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>The return type of a <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a></code> step.</p><p>A parser is driven by a parse driver one step at a time, at any time the
 driver may <code>extract</code> the result of the parser. The parser may ask the driver
 to backtrack at any point, therefore, the driver holds the input up to a
 point of no return in a backtracking buffer.  The buffer grows or shrinks
 based on the return values of the parser step execution.</p><p>When a parser step is executed it generates a new intermediate state of the
 parse result along with a command to the driver. The command tells the
 driver whether to keep the input stream for a potential backtracking later
 on or drop it, and how much to keep. The constructors of <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code> represent
 the commands to the driver.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Yield" class="def">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Yield offset state</code> indicates that the parser has yielded a new
 result which is a point of no return. The result can be extracted
 using <code>extract</code>. The driver drops the buffer except <code>offset</code> elements
 before the current position in stream. The rule is that if a parser
 has yielded at least once it cannot return a failure result.</p></td></tr><tr><td class="src"><a id="v:Skip" class="def">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Skip offset state</code> indicates that the parser has consumed the current
 input but no new result has been generated. A new <code>state</code> is generated.
 However, if we use <code>extract</code> on <code>state</code> it will generate a result from
 the previous <code>Yield</code>.  When <code>offset</code> is non-zero it is a backward offset
 from the current position in the stream from which the driver will feed
 the next input to the parser. The offset cannot be beyond the latest
 point of no return created by <code>Yield</code>.</p></td></tr><tr><td class="src"><a id="v:Stop" class="def">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</td><td class="doc"><p><code>Stop offset state</code> asks the driver to stop driving the parser because
 it has reached a fixed point and further input will not change the
 result.  <code>offset</code> is the count of unused elements which includes the
 element on which <code><a href="Streamly-Internal-Data-Parser-Types.html#v:Stop" title="Streamly.Internal.Data.Parser.Types">Stop</a></code> occurred.  Once a fold stops, driving it further
 may produce undefined behavior.</p></td></tr><tr><td class="src"><a id="v:Error" class="def">Error</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>An error makes the parser backtrack to the last checkpoint and try
 another alternative.</p></td></tr></table></div><div class="subs instances"><details id="i:Step" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-181" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parser" class="def">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>A parser is a fold that can fail and is represented as <code>Parser step
 initial extract</code>. Before we drive a parser we call the <code>initial</code> action to
 retrieve the initial state of the fold. The parser driver invokes <code>step</code>
 with the state returned by the previous step and the next input element. It
 results into a new state and a command to the driver represented by <code><a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a></code>
 type. The driver keeps invoking the step function until it stops or fails.
 At any point of time the driver can call <code>extract</code> to inspect the result of
 the fold. It may result in an error or an output value.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Parser" class="def">Parser</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-Types.html#t:Step" title="Streamly.Internal.Data.Parser.Types">Step</a> s b)) (m s) (s -&gt; m b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:Parser" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Monad:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-585" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Monad composition can be used for lookbehind parsers, we can make the
 future parses depend on the previously parsed values.</p><p>If we have to parse &quot;a9&quot; or &quot;9a&quot; but not &quot;99&quot; or &quot;aa&quot; we can use the
 following parser:</p><pre>backtracking :: MonadCatch m =&gt; PR.Parser m Char String
backtracking =
    sequence [PR.satisfy isDigit, PR.satisfy isAlpha]
    <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>
    sequence [PR.satisfy isAlpha, PR.satisfy isDigit]
</pre><p>We know that if the first parse resulted in a digit at the first place then
 the second parse is going to fail.  However, we waste that information and
 parse the first character again in the second parse only to know that it is
 not an alphabetic char.  By using lookbehind in a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> composition we can
 avoid redundant work:</p><pre>data DigitOrAlpha = Digit Char | Alpha Char

lookbehind :: MonadCatch m =&gt; PR.Parser m Char String
lookbehind = do
    x1 &lt;-    Digit <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isDigit
         <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> Alpha <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isAlpha

    -- Note: the parse depends on what we parsed already
    x2 &lt;- case x1 of
        Digit _ -&gt; PR.satisfy isAlpha
        Alpha _ -&gt; PR.satisfy isDigit

    return $ case x1 of
        Digit x -&gt; [x,x2]
        Alpha x -&gt; [x,x2]
</pre></td></tr><tr><td colspan="2"><details id="i:id:Parser:Monad:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; (a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:return" class="selflink">#</a></p><p class="src"><a href="#v:fail">fail</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:fail" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-216" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parser:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Applicative:3"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-320" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> form of <code><a href="Streamly-Internal-Data-Parser-Types.html#v:splitWith" title="Streamly.Internal.Data.Parser.Types">splitWith</a></code>.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Alternative:4"></span> MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-527" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> instance using <code><a href="Streamly-Internal-Data-Parser-Types.html#v:alt" title="Streamly.Internal.Data.Parser.Types">alt</a></code>.</p><p>Note: The implementation of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> is not lazy in the second
 argument. The following code will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) &lt;|&gt; undefined) $ S.fromList [1..10]
</code></strong></pre></td></tr><tr><td colspan="2"><details id="i:id:Parser:Alternative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a [a0] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a [a0] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:MonadPlus:5"></span> MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-630" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mzero" title="Control.Monad">mzero</a></code> is same as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>, it aborts the parser. <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mplus" title="Control.Monad">mplus</a></code> is same as
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>, it selects the first succeeding parser.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parser:MonadPlus:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a a0 <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:ParseError" class="def">ParseError</a> <a href="src/Streamly.Internal.Data.Parser.Types.html#ParseError" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></p><div class="doc"><p>This exception is used for two purposes:</p><ul><li>When a parser ultimately fails, the user of the parser is intimated via
    this exception.</li><li>When the &quot;extract&quot; function of a parser needs to throw an error.</li></ul><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ParseError" class="def">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:ParseError" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-211" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Exception:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.Types.html#line-213" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Exception:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-Types.html">Streamly.Internal.Data.Parser.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toException">toException</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> <a href="#v:toException" class="selflink">#</a></p><p class="src"><a href="#v:fromException">fromException</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a> <a href="#v:fromException" class="selflink">#</a></p><p class="src"><a href="#v:displayException">displayException</a> :: <a href="Streamly-Internal-Data-Parser-Types.html#t:ParseError" title="Streamly.Internal.Data.Parser.Types">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:displayException" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A parser that always yields a pure value without consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A parser that always yields the result of an effectful action without
 consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.Types.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Sequential application. Apply two parsers sequentially to an input stream.
 The input is provided to the first parser, when it is done the remaining
 input is provided to the second parser. If both the parsers succeed their
 outputs are combined using the supplied function. The operation fails if any
 of the parsers fail.</p><p>This undoes an &quot;append&quot; of two streams, it splits the streams using two
 parsers and zips the results.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) *&gt; undefined) $ S.fromList [1]
</code></strong></pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:die" class="def">die</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#die" class="link">Source</a> <a href="#v:die" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an error message without consuming
 any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dieM" class="def">dieM</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.Types.html#dieM" class="link">Source</a> <a href="#v:dieM" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an effectful error message and without
 consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitSome" class="def">splitSome</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.Types.html#splitSome" class="link">Source</a> <a href="#v:splitSome" class="selflink">#</a></p><div class="doc"><p>See documentation of <code><a href="Streamly-Internal-Data-Parser.html#v:some" title="Streamly.Internal.Data.Parser">some</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitMany" class="def">splitMany</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.Types.html#splitMany" class="link">Source</a> <a href="#v:splitMany" class="selflink">#</a></p><div class="doc"><p>See documentation of <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:alt" class="def">alt</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.Types">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.Types.html#alt" class="link">Source</a> <a href="#v:alt" class="selflink">#</a></p><div class="doc"><p>Sequential alternative. Apply the input to the first parser and return the
 result if the parser succeeds. If the first parser fails then backtrack and
 apply the same input to the second parser and return the result.</p><p>Note: This implementation is not lazy in the second argument. The following
 will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) `PR.alt` undefined) $ S.fromList [1..10]
</code></strong></pre><p><em>Internal</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>